#+TITLE: Spruce's Emacs
#+AUTHOR: Spruce Bondera
#+PROPERTY: header-args  :tangle yes
#+OPTIONS: toc:nil
* About
This file, and the others it references, contain my Emacs configuration. I've
been using Emacs since around 2014, and using it heavily since mid-2015. Over
the course of the next year and a half I accumulated a serious amount of config
and packages of various forms. Emacs is software with a hilariously high
potential ceiling (I haven't caught a glimpse of it yet), but in my view pretty
terrible defaults. A large part of my switch to fully using it was due to
accumulating the critical mass of configuration necessary to use it without
significant annoyance.

It's easy to just throw config in your =.emacs= or =init.el=, which is what I did
for over a year and a half. However at a certain point it accumulates cruft,
competing and contradictory code, becomes impossible to search through, and even
worse to debug. It's somewhat common in the Emacs community to deal with this
through literate programming through =org-mode=. The code becomes somewhat
secondary to documentation and organization, making it easier to keep track of
and modify. This is my ongoing attempt to organize, clean up, and improve my
config. Started October 15th, 2016.
** Why Emacs
Emacs is one of only two text editors that have seen consistent, somewhat
widespread, use and development for the last 35+ years. The other of course
being vi/vim. Throughout that period, Emacs has consistently been the less
popular of the two. I think this is largely because of its /philosophy/ as opposed
to usability differences. In fact, especially compared to modern editors, Emacs
is much easier to get started with. But the combination of terrible initial
presentation and difficulty of fully embracing the philosophy means adoption
rates are low.

Nowadays, the majority of new programmers use IDEs and newer editors, such as
Sublime Text and Atom. My opinion on IDEs is relatively simple: I dislike
unspecific over-specific tools. For example, I've used several IntelliJ IDEs
(PyCharm and CLion), and while both have many useful features, the fact that
they aren't the same program supporting multiple languages, the fact that the
interface is slightly different, the fact that configuration is somewhat
difficult to export, and the fact that if I needed to write some other language
they don't have an IDE for I would need to learn a whole new editing interface
and configuration system, beyond just the IDE specific tools, combine to annoy
me. There's also a more minor aesthetic point of the incredible amount of
clutter and graphical menus involved in these kinds of tools. Of course in some
situations the benefits are simply to great to pass up (or actually required).
For example I don't know of any reliable way to develop an iOS app outside of
Xcode, and realistically while Xcode is not my favorite program to use, it has a
massive amount of support for writing iOS applications, and an international
company pouring money into further improvements.

But outside of those situations, many people come to the same conclusion as me.
This is generally the reasoning that leads people towards text editors rather
than IDEs. Text editors can almost always be customized sufficiently to provide
the productivity benefits of an IDE, but while keeping a consistent interface
and much lower initial complexity. There may also be a factor of barrier to
entry. IDEs are largely impenetrable to new developers, so they may start out
with a text editor and feel uncomfortable switching by the time they could make
use of an IDE. I'm unsure as to any statistics on this front (as an anecdatum, I
started out using an IDE and later switched to a text editor, but that was
largely because I felt I wasn't making use of the IDEs features rather than
because of my current philosophical objections). Currently, especially among
students and somewhat recent graduates, Sublime Text seems to be the most common
choice. Indeed, I used it myself for about two and a half years, and amassed a
reasonably extensive configuration.

And really, for me, what this all comes down to is configuration. It seems like
there's a mindset that some people acquire, and some haven't (or haven't yet).
That mindset being: mold your tools to yourself, not yourself to your tools. At
very least software (if not the rest of your life) should be changed to iron out
every minor annoyance, to maximize efficiency and collapse repeated actions, to
be ergonomic and enjoyable. While making the physical world conform to this goal
is daunting, doing it with software is much more achievable.

Which is why, eventually, slowly, I switched to Emacs. Sublime Text is a
full-featured and highly customizable application, but it cannot compare to
Emacs. Simply put, the old joke is correct. Emacs is not really a text editor
and hasn't been for decades. It's a Lisp Machine, a text-based Lisp operating
system whose code is readable, modifiable, and extensible. Most importantly, it
has consistent interfaces for doing so.


** Literate Configuration

* Contents                                        :TOC_2_gh:
- [[#about][About]]
  - [[#why-emacs][Why Emacs]]
  - [[#literate-configuration][Literate Configuration]]
- [[#bootstrap][Bootstrap]]
  - [[#security][Security]]
  - [[#utility-functions][Utility Functions]]
  - [[#configuration-management][Configuration Management]]
  - [[#personal-information][Personal Information]]
  - [[#default-settings][Default Settings]]
  - [[#keybindings][Keybindings]]
  - [[#macos][macOS]]
- [[#appearance][Appearance]]
  - [[#basic-tweaks][Basic Tweaks]]
  - [[#theme][Theme]]
  - [[#mode-line][Mode Line]]
  - [[#appearance-packages][Appearance Packages]]
- [[#general][General]]
  - [[#helm][Helm]]
  - [[#projectile][Projectile]]
  - [[#company][Company]]
  - [[#magit][Magit]]
  - [[#ess][ESS]]
  - [[#irc][IRC]]
  - [[#non-programming-modes][Non-Programming Modes]]
  - [[#default-package-configuration][Default Package Configuration]]
  - [[#misc-packages][Misc Packages]]
  - [[#fun][Fun]]
- [[#programming][Programming]]
  - [[#prog-mode][Prog Mode]]
  - [[#cc-mode][CC Mode]]
  - [[#python][Python]]
  - [[#emacs-lisp][Emacs Lisp]]
  - [[#coffeescript][Coffeescript]]
  - [[#haskell][Haskell]]
- [[#org][Org]]
- [[#latex][LaTeX]]
- [[#the-heap][The Heap]]
  - [[#tweak-heap][Tweak Heap]]
  - [[#package-heap][Package Heap]]
  - [[#old-heap][Old Heap]]
- [[#utility-functions-1][Utility Functions]]

* Bootstrap
** Security
There are several important security improvements to Emacs that should come as
early a possible in config, to prevent inevitable network connection attempts
from being hilariously insecure.
*** TLS
Much of the following is credited to [[https://glyph.twistedmatrix.com/2015/11/editor-malware.html][Glyph]].

~network-security-level~ sets how careful Emacs is with network security. The
default is =medium=, but I prefer =high=, as it prevents a few more problematic
practices. =paranoid= is a little far for me though.
#+BEGIN_SRC emacs-lisp
(setq network-security-level 'high)
#+END_SRC

However this only matters in Emacs 25 and higher. For older versions, network
connections are not secure by default at all. This enables TLS checking.

#+BEGIN_SRC emacs-lisp
(setq tls-checktrust t)
#+END_SRC

All of the above only applies to Emacs not built with an external TLS checker.
However if it is built with one like GnuTLS, some extra config is necessary.

#+BEGIN_SRC emacs-lisp
(let ((trustfile
       (replace-regexp-in-string
        "\\\\" "/"
        (replace-regexp-in-string
         "\n" ""
         (shell-command-to-string "python -m certifi")))))
  (setq tls-program
        (list
         (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                 (if (eq window-system 'w32) ".exe" "") trustfile)))
  (setq gnutls-verify-error t)
  (setq gnutls-trustfiles (list trustfile)))
#+END_SRC

This ensures that TLS is configured correctly, and prevents further config
evaluation otherwise. Currently disabled for speed.

#+BEGIN_SRC emacs-lisp :tangle no
(let ((bad-hosts
       (loop for bad
             in `("https://wrong.host.badssl.com/"
                  "https://self-signed.badssl.com/")
             if (condition-case e
                    (url-retrieve
                     bad (lambda (retrieved) t))
                  (error nil))
             collect bad)))
  (if bad-hosts
      (error (format "tls misconfigured; retrieved %s ok"
                     bad-hosts))
    (url-retrieve "https://badssl.com"
                  (lambda (retrieved) t))))
#+END_SRC

This fixes a bug in the rich text parsing.
#+BEGIN_SRC emacs-lisp
;; Mitigate Bug#28350 (security) in Emacs 25.2 and earlier.
(eval-after-load "enriched"
  '(defun enriched-decode-display-prop (start end &optional param)
     (list start end)))
#+END_SRC

** Utility Functions
I have a number of functions not particularly tied to a specific mode or
feature-set. Many of them were defined exclusively to be accessible through a
keybinding, however if I deem them sufficiently general they get put in the
Utility Functions section, and included up here. These functions are in fact
defined at the bottom of this file, but are accessible to all config below this
point. The code that does this is not visibly exported.
#+BEGIN_SRC emacs-lisp :noweb tangle :exports none
<<utility-functions>>
#+END_SRC

** Configuration Management
*** =use-package=
I use the =use-package= package [[https://github.com/jwiegley/use-package][(here)]] to configure both Emacs and the large
number of other packages I use.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(require 'use-package)
;; All packages in a use-package macro should be automatically installed
(setq use-package-always-ensure t)
#+END_SRC
Additionally, I use the ~:diminish~ feature of =use-package= to hide various minor
modes from my mode line.
*** TODO =validate=
=validate= is a package that tries to minimize invalid variable values. Emacs and
many packages have user-configurable variables that should only hold certain
values, perhaps only integers or only one of a list of symbols. It's possible to
subtly misconfigure these, potentially letting Emacs to continue to run until
some feature is called and behaves wildly unexpectedly. So I use =validate= and
~validate-setq~ whenever possible.
#+BEGIN_SRC emacs-lisp
(use-package validate)
#+END_SRC

*** External Files
I have several external config files loaded by this one. These are given
variable names and added to a global list in various sections in this file. To
do this I use the following macro and list:

#+BEGIN_SRC emacs-lisp
(setq-default spruce/org-config-directory "literate")
(setq-default spruce/org-config-dirpath
              (expand-file-name (with-user-d spruce/org-config-directory)))
(setq-default spruce/config-package-directory "packages")
(setq-default spruce/config-package-dirpath
              (expand-file-name
               (concat-directories spruce/org-config-dirpath
                                   spruce/config-package-directory)))
(add-to-list 'load-path spruce/org-config-dirpath)
(add-to-list 'load-path spruce/config-package-dirpath)
(setq-default spruce/config-org-files nil)

;; transforms the given name to "spruce/name-config-file" and sets it
;; to the given org filename
(defmacro spruce/new-config-file (name filename)
  (let ((full-file (make-symbol "full-filename")))
    `(let ((,full-file
            (concat (file-name-as-directory spruce/org-config-dirpath) ,filename ".org")))
       (defvar ,(intern (concat "spruce/" (symbol-name name) "-config-file"))
         ,full-file)
       (add-to-list
        (quote spruce/config-org-files) (quote (,name . ,filename)) t))))
#+END_SRC

*** =customize=
Emacs has a built-in customization interface which auto-inserts code into your
init file. This is useful for many people and makes it pretty easy to discover
and configure settings, but I generally don't use it anymore and dislike the
undocumented format. However sometimes these settings still crop up, so I dump
them in a file and eventually configure them correctly.
#+BEGIN_SRC emacs-lisp
(setq custom-file
      (concat
       (file-name-as-directory spruce/org-config-dirpath)
       "temp-custom.el"))
(load-file custom-file)
#+END_SRC

*** Table of Contents
While =org= exports nice tables of contents by default, they don't appear directly
in org files, and GitHub doesn't render them. So I use a package that (somewhat
worryingly) automatically inserts a table of contents into the actual org file.
#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :config
  (add-hook 'org-mode-hook 'toc-org-enable))
#+END_SRC

** Personal Information
My name and primary email for use in various other places.
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Spruce Bondera"
      user-mail-address "sprucebondera@gmail.com")
#+END_SRC

** Default Settings
*** Modernization
Emacs is very old, and has a number of defaults that reflect this age. Some of
these I like, many I don't.

It's normal text editing behavior to automatically replace selected text if a
new character is typed.
#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

In Fundamental mode, use a single spaces after sentence-ending periods. Double
spaces are from the typewriter period and should not be used in modern
documents.
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

Emacs is user-level software, not a shell, so some protection is nice. Using a
Trash is one such protection I occasionally still appreciate.
#+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash t)
#+END_SRC

Like some terminal emulators, graphical Emacs clients resize "line/column"-wise
by default (i.e. snapping to the nearest line or column). In theory this could
be useful, but it's wildly unexpected and odd looking in modern systems. This
setting tries to make "frames" (Emacs' term for windows) resize normally.
#+BEGIN_SRC emacs-lisp
(setq frame-resize-pixelwise t)
#+END_SRC

*** Parentheses Highlighting
Highlight corresponding parentheses if the cursor is over one of them. This is
pretty important in most languages, especially with the S-expression
manipulations I often perform.
#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0)
(show-paren-mode t)
#+END_SRC

*** Scratch buffer
I prefer a blank scratch buffer. The default message is just going to be deleted
anyway. In the future I may set some more complicated and useful programmatic
message as the default, but for the moment an empty buffer is the most useful
option.
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message "")
#+END_SRC

*** Backups
I have plenty of disk space, so as many backups as possible is great. However I
definitely don't want them cluttering up random directories.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `((".*" . ,(with-user-d "backups/")))
      backup-by-copying t    ; Don't delink hardlinks
      version-control t      ; Use version numbers on backups
      delete-old-versions 'never)
#+END_SRC

Additionally I want to autosave early and often, but not cause clutter.
#+BEGIN_SRC emacs-lisp
(setq auto-save-list-file-prefix
      (with-user-d-s ".saves-" "autosaves"))
(setq auto-save-interval 100) ; 100 characters
(setq auto-save-timeout 10)   ; or 10 seconds
#+END_SRC

*** ~kill-line~
By default =C-k= or ~kill-line~ doesn't truly delete the line, but rather kills all
the text on it while leaving the newline. There are situations where this is
useful, but overall I prefer deletion of the entire line.
#+BEGIN_SRC emacs-lisp
(setq kill-whole-line t)
#+END_SRC
I also appreciate having the ability to kill backwards easily.
#+BEGIN_SRC emacs-lisp
(bind-key "H-<backspace>" 'backward-kill-line)
#+END_SRC

*** Garbage Collection Performance
The default garbage collection of Emacs is quite aggressive. It collects garbage
after around 800KB of allocation. This is tiny for modern systems. However even
though I usually have >= 16GB of RAM, setting the garbage collection threshold
too high leads to occasional but very noticeable pauses, as large swaths of
memory are reclaimed. I think ~10MB is a pretty reasonable balance, but I may
tweak this in the future.

This runs on a timer, waiting until the user has been idle for 5 seconds before
actually setting the threshold. This is because I increase the threshold to
about 500 MB as the first line in ~init.el~, to improve Emacs' startup speed.

#+BEGIN_SRC emacs-lisp
(run-with-idle-timer
 5 nil
 (lambda ()
   (setq gc-cons-threshold 10000000)
   (message "gc-cons-threshold restored to %S"
            gc-cons-threshold)))
#+END_SRC

*** =fill-column=
I generally like to fill (i.e. redistribute line breaks to not go past a certain
point) my text and code, to make it easier to browse in various situations and
edit in multiple frames. I tend towards 80 characters in free text, and a loose
80 in code (some lines are much less readable if broken up purely for consistency).
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC

*** Scrolling Context Jumps
When paging down I tend to lose track of what I was reading unless some of the
previous page remains. A full half-screen is a little much, but around 4 lines
is usually enough for me to keep my bearings.
#+BEGIN_SRC emacs-lisp
(setq next-screen-context-lines 5)
#+END_SRC

*** Mark Ring
The mark ring contains information about where marks (selection points) were
set. Since I have a modern computer I see no reason for this to be small.
#+BEGIN_SRC emacs-lisp
(setq global-mark-ring-max 2000)
(setq mark-ring-max 1000)
#+END_SRC
Also, I like to be able to pop repeatedly more easily.
#+BEGIN_SRC emacs-lisp
(setq set-mark-command-repeat-pop t)
#+END_SRC

*** Unicode
UTF-8 is pretty much the standard everywhere now. Better yet, unless I
specifically add "special" (non-ASCII) characters to a buffer, UTF-8 is
identical to ASCII, which is nice for compatibility with older programs.
#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq default-buffer-file-coding-system 'utf-8)
#+END_SRC

**** TODO Double check the ~set-terminal-coding-system~ portability

*** Enabling "dangerous" commands
There's a number of commands that Emacs considers potentially destructive or
dangerous for new users. I honestly think that in general this is a good
feature, but it can be annoying at times. Here I enable several of these
dangerous functions that I both understand and use.
#+BEGIN_SRC emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
#+END_SRC

In the same vein, when editing a symlinked and version controlled file (i.e.
opening a symlink to a file in version control) by default Emacs double checks
that this is in fact what you want to do, since various issues can arise if you
don't follow the link. I don't have any situations where I don't want to follow
said links, and it's less nagging.
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC

*** Debug on error
There are a lot of things that can go wrong in Emacs, especially with as much
config as I've got here. Fixing them is of course important, but the default
behavior is to immediately throw you into a debugger. I prefer to
just get a message and handle it on my own terms.
#+BEGIN_SRC emacs-lisp
(setq debug-on-error nil)
#+END_SRC

*** Visual Bell
Emacs sends "bells" relatively often (i.e. every time ~keyboard-quit~ is called).
Playing an actual sound for these gets really annoying really fast. However
using the "normal" setting of ~visable-bell~ true has caused odd problems on macOS
in the past. So for the time being I simply override the function that's meant
to play the bell sound with flashing the mode line for a tenth of a second.
#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
(setq ring-bell-function
      (lambda () (invert-face 'mode-line)
        (run-with-timer 0.1 nil 'invert-face 'mode-line)))
#+END_SRC

*** Yes or no
There's a lot of yes or no prompts in Emacs, some of which I specifically enable
to keep myself from making mistakes. However I feel confident enough in my own
competence to press =y= or =n= rather than a full =yes= or =no=.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Keybindings
*** Config File Access
Quickly getting to my config file is important for fluid customization. Just as
programming and discovery is faster with a REPL. Emacs is really just one large
REPL, so I make it easier to use as such.
#+BEGIN_SRC emacs-lisp
(defun spruce/open-config-file ()
  (interactive)
  (find-file (or spruce/bootstrap-org-path
                 user-init-file "")))
(bind-key "C-c e" 'spruce/open-config-file)
#+END_SRC

Similarly I like to be able to quickly re-eval my entire config. This involves
evaling my init file, rather than this file.
#+BEGIN_SRC emacs-lisp
(defun spruce/eval-config ()
  (interactive)
  (load-file user-init-file))
(bind-key "H-C-e" 'spruce/eval-config)
#+END_SRC

*** Quick Fullscreen Mode
#+BEGIN_SRC emacs-lisp
(bind-key "H-<return>" 'toggle-frame-fullscreen)
#+END_SRC

*** Line Shifting
Occasionally I like to shift whole lines up and down through a buffer. These
make it easier and more natural than killing and yanking.
#+BEGIN_SRC emacs-lisp
(bind-keys ("M-S-<up>" . move-line-up)
           ("M-S-<down>" . move-line-down))
#+END_SRC

*** Buffer Reversion
I find myself needing to revert buffers weirdly often. I now try to solve this
with ~auto-revert-mode~ as much as possible, but this is still helpful.
#+BEGIN_SRC emacs-lisp
(bind-key "H-r" 'revert-buffer-no-prompt)
#+END_SRC

*** Macro Recording
It took me a while to understand and get used to the idea of keyboard macros.
Especially since they interact oddly with packages such as Helm. However once I
did start using them I found defining slightly more memorable shortcuts to be helpful.
#+BEGIN_SRC emacs-lisp
(bind-keys ("M-[" . kmacro-start-macro)
           ("M-]" . kmacro-end-macro))
#+END_SRC

** macOS
I run [[https://bitbucket.org/mituharu/emacs-mac/overview][Mitsuharu Yamamoto's]] =emacs-macport= on the latest
version of macOS. There are several configuration options specific to
this platform that I use.

These settings are kept in a separate file for clean tangling
conditional on the operating system.

#+BEGIN_SRC emacs-lisp
(spruce/new-config-file macOS "macOS")
(when (eq system-type 'darwin)
  (org-babel-load-file spruce/macOS-config-file))
#+END_SRC

* Appearance
Aesthetic is important. Ugly things are distracting and unpleasant. Emacs
without any configuration looks terrible, so I've done quite a bit of work to
fix that.
** Basic Tweaks
These are simple changes to the default settings.

*** Useless Information
The tool bar is both useless and ugly. Same for the scroll bar. Disable both.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

Additionally, I dislike the startup message. The logo is ancient, and after
seeing it a few times the message is irrelevant. I use =desktop-mode=, but in the
situations where I do start from scratch, I prefer to start in =*scratch*=.
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC

*** Cursor
Somewhat similar to modern editors, I prefer a 1-pixel wide bar
cursor. However having a distinctive shape in non-active buffers
(rather than simply not blinking as in many other programs) is also quite useful.
#+BEGIN_SRC emacs-lisp
(setq-default cursor-type '(bar . 1))
(setq-default cursor-in-non-selected-windows 'hollow)
#+END_SRC

*** Frame Titles
Window titles include a lot of unnecessary information by default. I generally
find 3 things important: the buffer name, its mode, and whether it's been saved.
#+BEGIN_SRC emacs-lisp
(setq frame-title-format '("" "%b %* [%m]"))
#+END_SRC

*** Fringe Wrap Indicators
The default fringe overage symbols are extremely ugly arrows. Unfortunately,
there is no way to use high resolution images for these. They literally must be
8x8 bitmaps, which explains why they're so ugly in the first place. However this
sequence of pseudo-dots looks a good bit better in my eyes.
#+BEGIN_SRC emacs-lisp
(define-fringe-bitmap 'right-curly-arrow
  [#b00000000
   #b00000000
   #b00000000
   #b00000000
   #b01010100
   #b01010100
   #b01010100
   #b00000000])

(define-fringe-bitmap 'left-curly-arrow
  [#b00000000
   #b00000000
   #b00000000
   #b00000000
   #b01010100
   #b01010100
   #b01010100
   #b00000000])
#+END_SRC

*** Prettify Symbols
Similarly, I like to have nice many text representations of symbols replaced
with those symbols. i.e. in =emacs-lisp= mode I see "lambda" as λ. This is
especially useful for LaTeX editing. However I also like to edit the real
underlying text easily, so I set the symbols to revert whenever the cursor is
touching.
#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode)
(setq prettify-symbols-unprettify-at-point 'right-edge)
#+END_SRC

*** Window Dividers
Window divider mode, new in emacs 25, allows for a divider similar to the
vertical border to be placed in various positions around windows. I use this to
keep a one-pixel wide line below and to the right of windows, meaning they are
surrounded on all sides by the border. Without this, there is no such line
between adjacent modelines etc. I feel this leads to a more consistent
appearance.
#+BEGIN_SRC emacs-lisp
(when (boundp 'window-divider-mode)
  (setq window-divider-default-places t
        window-divider-default-bottom-width 1
        window-divider-default-right-width 1)
  (window-divider-mode +1))
#+END_SRC

** Theme
My specific appearance preferences.
*** Blue Spruce
This is the actual theme I use. It started as a modified version of Doom Theme,
which I extracted as a separate ~.el~ because of the number of changes I needed to
make.

#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path (concat spruce/org-config-dirpath "blue-spruce/"))
(load-theme 'blue-spruce t)
#+END_SRC

*** Font
A good font is always important, especially so when programming. Fixed-width is
essential for vertical alignment. There must be a good distinction between
somewhat visually similar characters (l, I, and 1, etc). Preferably there should
be good support for Unicode and various special symbols, but Emacs is pretty
unique in its font fallback system (it will automatically search for alternate
fonts if the default doesn't support a certain codepoint, and use the alternate
only for that individual character).

I've chosen Source Code Pro, and been using it for over 3 years. There's a
variety of newer fonts that include interesting ligatures and generally look
pretty good, so I might switch at some point in the future. But for now:

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :font "Source Code Pro-12")
#+END_SRC

** Mode Line
After many years of failed attempts to make a good looking modeline with
Powerline, Smart Modeline, Spaceline, etc, I eventually gave in and learned to
deal with ~mode-line-format~ on my own. I've written up a good bit of config to
make my modeline look reasonably nice, but there's always more work to do.
#+BEGIN_SRC emacs-lisp
(spruce/new-config-file blue-spruce-modeline
                        "blue-spruce/blue-spruce-modeline")
(org-babel-load-file spruce/blue-spruce-modeline-config-file)
#+END_SRC

** Appearance Packages
A few packages that can be used to improve Emacs' appearance. Not currently in
use.
#+BEGIN_SRC emacs-lisp
;; Uses fonts to allow usage of many different icons
(use-package all-the-icons)
;; A "file sidebar" package
(use-package neotree)
#+END_SRC

* General
** Helm
Helm is probably the most important package I use. At its core, it's just an
alternative selection system. Selection is an extremely common activity in
Emacs, selecting a file, using M-x to select a command, selecting a buffer to
switch to, etc. Helm provides a consistent, sane, and incredibly convenient
framework for selection, including the best search method I have ever seen. My
only complaint about it is going back to other applications where selecting
commands or finding files takes actual mental effort.

Helm can plug into and replace a large number of Emacs features, as well as many
other packages. I generally put such configs in the other packages, as I now
view Helm as more part of my default Emacs rather than a separate package. For
default Emacs features, a large part of this "plugging in" is just rebinding
default keybindings to Helm versions of Emacs commands.
*** Helm Proper
This is my Helm =use-package=. I use noweb to tangle source blocks below inside
the use-package.
#+BEGIN_SRC emacs-lisp :noweb tangle
(use-package helm
  :diminish helm-mode
  :init (require 'helm-config)
  :config
  ;; Enable Helm globally
  (helm-mode t)
  <<helm-fuzzy-matching>>
  <<helm-window-split>>
  <<helm-company-projectile>>
  <<helm-set-locate-command>>
  ;; Note: due to how noweb works, there cannot be any non-whitespace characters
  ;; on a line prior to a <<block>> construct. This is why there's a newline
  ;; after the first open-paren here.
  :bind (
         <<helm-replace-defaults>>
         <<helm-persistent-action>>))
#+END_SRC
Note: the below is still included inside the Helm =use-package=.
**** Fuzzy Matching
Fuzzy matching makes my typos less important and also doesn't get in my way when
I know exactly what I want.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-fuzzy-matching :tangle no
(setq helm-M-x-fuzzy-match t)
(setq helm-mode-fuzzy-match t)
#+END_SRC

**** Window Split
Default Helm can open buffers in weird and disorienting positions. I prefer it
always attempting to pop up as if from the mode line.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-window-split :tangle no
(setq helm-split-window-in-side-p t)
#+END_SRC

**** Company/Projectile
Move to company/projectile configs
#+BEGIN_SRC emacs-lisp :noweb-ref helm-company-projectile :tangle no
(with-eval-after-load 'company
  (bind-key "C-'" 'helm-company company-mode-map)
  (bind-key "C-'" 'helm-company company-active-map))
(with-eval-after-load 'projectile
  (setq projectile-completion-system 'helm))
#+END_SRC

**** Defaults Replacement
While Helm replaces several default Emacs functions to make many commands behave
better, it also has specialized versions with extra features. I replace as many
default options as possible.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-replace-defaults :tangle no
("M-x" . helm-M-x)
("C-x C-f" . helm-find-files)
("C-x b" . helm-mini)
("C-x C-b" . helm-buffers-list)
("C-c h o" . helm-occur)
("M-s o" . helm-occur)
#+END_SRC

**** Persistent Action
In Helm a persistent action is something that can be done in a Helm buffer
without ending the session. By default it's bound to C-z, and tab is bound to
selection of a non-persistent action. I prefer swapping C-z and tab
functionality.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-persistent-action :tangle no
:map helm-map
("<tab>" . helm-execute-persistent-action)
("C-i" . helm-execute-persistent-action) ; for use in terminal
("C-z" . helm-select-action)
#+END_SRC

**** Locate Command
~helm-locate~ is an extremely useful command to find arbitrary files on the
file-system. It's best to do this using an external tool. I pick which one based
on the current operating system. However if this is macOS, then this was already
set in my macOS.org config file.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-set-locate-command :tangle no
  (unless (eq system-type 'darwin)
    (setq helm-locate-command
          (case system-type
            ('gnu/linux "locate -i -r %s")
            ('berkeley-unix "locate -i %s")
            ('windows-nt "es %s")
            (t "locate %s"))))
#+END_SRC

*** Helm Flx
=flx= is a package that allows for Sublime-like great fuzzy matching. =helm-flx=
plugs in this functionality to Helm's fuzzy matching.
#+BEGIN_SRC emacs-lisp
(use-package helm-flx
  :config (helm-flx-mode t))
#+END_SRC

*** Helm Projectile
Projectile is another incredibly important package for me, and of course I'd
like to use Helm for all of its various features.
#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :config
  (with-eval-after-load 'projectile
    (helm-projectile-on)))
#+END_SRC

*** =helm-swoop=
=helm-swoop= is a replacement for ~isearch~ and ~occur~ that searches buffers with a
Helm-based interface and automatically moves through the searched buffer and
highlights the matches. It also allows for editing the searches in a separate
buffer and saving them back.
**** Swoop Proper
#+BEGIN_SRC emacs-lisp :noweb tangle
(use-package helm-swoop
  :config
  <<helm-swoop-window-splitting>>
  <<helm-swoop-output-color>>
  <<helm-swoop-reactivate-mark>>
  <<helm-swoop-ci-translation>>
  :bind (
         <<helm-swoop-search-rebinds>>
         <<helm-swoop-switch-to-multi>>))
#+END_SRC

**** Swoop Window Splitting
Do the same window split as with the rest of Helm, i.e. inside the current
buffer and vertically if possible.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-window-splitting :tangle no
(setq helm-swoop-split-with-multiple-windows t)
(setq helm-swoop-split-direction 'split-window-vertically)
#+END_SRC

**** Font Lock in Searches
Keep the font lock (color/highlighting etc) from the searched buffer in the
results. This slows down the search, but not very perceptibly.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-output-color :tangle no
(setq helm-swoop-speed-or-color t)
#+END_SRC

**** Mark Reactivation
For some reason helm-swoop deactivates the mark on search selection. This
wrapper fixes that, by wrapping helm-swoop in a function that will reactivate
the mark if it was set before search started.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-reactivate-mark :tangle no
(defun spruce/helm-swoop-mark-wrapper (original &rest search)
  "Check the state of the mark before calling helm-swoop and
re-activate it after swooping if it was active before-hand"
  (let ((marked mark-active))
    (apply original search)
    (when marked (activate-mark))))
(advice-add 'helm-swoop :around #'spruce/helm-swoop-mark-wrapper)
#+END_SRC

**** Search Keybindings
I replace the default isearch binding with swoop. I also tend to type new
searches more often than I use the symbol at the point, so I use the
no-pre-input version. However, isearch is an important tool for navigation, so I
rebind it to an easy-to-reach key, C-i. Unfortunately this is viewed by Emacs as
the same character as <tab> due to deficiencies of old keyboards. So I have to
instead have it translate a literal C-i (but not <tab>) to H-i first, and then
bind H-i to isearch.

So this block must go in :config and does the translation:
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-ci-translation :tangle no
(keyboard-translate ?\C-i ?\H-i)
#+END_SRC
and this one does the actual keybinding.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-search-rebinds :tangle no
:map global-map
("C-c s" . isearch-forward)
("H-i" . isearch-forward)
("C-s" . helm-swoop-without-pre-input)
("C-M-s" . helm-swoop) ; with input of thing-at-point
("C-H-s" . helm-multi-swoop-projectile)
:map isearch-mode-map
("C-i" . isearch-repeat-forward)
#+END_SRC

**** Multi-Swoop
Multiswoop, swooping across multiple buffers, is pretty useful. Reasonably often
I realize a search I started in one buffer needs to expand across multiple, so I
use this binding to switch to multiswoop from inside a normal swoop.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-switch-to-multi :tangle no
:map helm-swoop-map
("M-i" . helm-multi-swoop-all-from-helm-swoop)
#+END_SRC

** Projectile
Projectile is another critical package. It's a project management utility and
framework. The main idea is simply that certain folders can be designated as
"projects", and you can then use utilities to manipulate or process files in
that folder specifically. Examples include: searching all files in a project,
searching through all open buffers for just the current project, saving or
killing all buffers in a project, opening a specific project known to Projectile
from anywhere "in Emacs" (even remote/TRAMP projects), etc. Also, generally
acting as a way for other packages to limit the scope of their function while
still taking multiple related files into account.

By default, a project is any git repo. There is also support for making non-git
folders into projects, with a ~.projectile~ file.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :diminish
  :config
  ;; Enable projectile globally
  (projectile-global-mode)
  ;; Make the current folder a projectile project
  (defun spruce/init-projectile ()
    (interactive)
    (let ((projectile ".projectile"))
      (unless (file-exists-p projectile)
        (write-region "" nil projectile)))))
#+END_SRC

** Company
Company is the completion framework I use. It requires a backend for each
language, but generally works quite well. It can use a "mini-popup" at the
cursor, similar to many IDEs and modern editors. I also have Helm completion for
more involved search.

#+BEGIN_SRC emacs-lisp
;; I almost always have Company on, so no need to see in the modeline
(use-package company
  :diminish
  :config
  ;; Should be enabled in every programming mode
  (add-hook 'prog-mode-hook 'global-company-mode)
  ;; C-tab is a good compromise between tab completion and indenting
  :bind ("C-<tab>" . company-complete))
#+END_SRC

** Magit
Magit is another of the most important packages I use. It's a Git porcelain, a
higher level interface to git. In many ways you can see this as similar to the
"graphical" version control interfaces built into many IDEs and programs such as
the Github Desktop app. And that is true, Magit is a non-CLI interface. But
unlike most such Git wrappers, Magit offers a good bit MORE power than the
normal command line, wrapping some complicated but useful operations into single
commands, but still exposing everything you can do on the command line. It also
allows for many many kinds of complex visualizations of diffs, logs, and data,
stuff that would require some external processing to get out of normal git
commands.

Especially important is that it's in Emacs. It's an Emacs-based UI (although one
of the better ones), it has the same keyboard shortcuts and config, it's
incredibly easy to access while editing. Honestly, even if it was a poor git
porcelain, I'd probably use it most of the time. But not only is it more
convenient than switching to a command prompt, it's also faster and easier to
use, and generally pretty beautiful.

Of course it's still a good idea to be comfortable with the git CLI. It's one of
the most ubiquitous tools in software, and you don't always have Emacs
everywhere (yet).

#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
  (setq magit-auto-revert-mode t)
  (setq magit-diff-refine-hunk 'all)
  :bind ("C-c g" . magit-status))
#+END_SRC

** ESS
ESS: Emacs Speaks Statistics. This is a large and old package allowing for
working with a variety of stats programs and languages. I have only ever used
this for R, and it works quite well for that.

#+BEGIN_SRC emacs-lisp
(use-package ess
  :defer 3
  :init (require 'ess-site)
  :config
  ;; aggressive-indent interfears with the ESS REPL
  (with-eval-after-load 'aggressive-indent
    (add-hook 'inferior-ess-mode-hook #'spruce/disable-agressive-indent)))
#+END_SRC

** TODO IRC
This is for configuration of IRC in Emacs. Currently I just use the Circe
package with no configuration.

#+BEGIN_SRC emacs-lisp
(use-package circe)
#+END_SRC

** Non-Programming Modes
These are various modes (major and minor) that aren't particularly related to
programming
*** Markdown
Markdown is a simple and ubiquitous markup language. I used it before switching
to Emacs, and generally find it reasonable to work with (although of course now
I use Org).
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode "\\.md\\'" ; This means to activate on .md files
  :config
  (add-hook 'markdown-mode-hook 'visual-line-mode))
#+END_SRC

** Default Package Configuration
Emacs has a large number of "packages" that are built in. This modularizes the
massive amount of available functionality. I tend to still use ~use-package~
blocks for tweaks to these default packages. It's more consistent and visually
pleasing.
*** TRAMP
TRAMP, "Transparent Remote Access, Multiple Protocols", is Emacs' method for
communicating with and editing files on remote servers. Its beauty and utility
comes from its ability to transparently allow Emacs functionality to work
remotely as if it were working locally, and to do so over many different kinds
of remote connections.

The problem is that it isn't perfect. Sometimes issues can arise, and there are
many warts left over from ancient compatibility concerns. It can feel
drastically slower at times (mostly due to Emacs' "issues" with multithreading).
But when it does work well, it's massively convenient.
#+BEGIN_SRC emacs-lisp
(use-package tramp
  :config
  ;; Use SSH ControlMasters to try to keep any connections alive as long as
  ;; possible. This gets rid of a lot of time spent reconnecting and
  ;; re-inputting credentials
  (setq tramp-ssh-controlmaster-options
        "-o ControlMaster=auto -o ControlPath='tramp.%%C' -o ControlPersist=yes")
  ;; SSH is generally the best remote connection method
  (setq tramp-default-method "ssh"))
#+END_SRC

*** Recentf
Recentf is a builtin package that keeps a list of recently visited files. The
utility is pretty obvious, and I keep this on at all times.
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :config
  (setq recentf-max-menu-items 1000)
  (setq recentf-max-saved-items 200)
  (recentf-mode t)
  :bind ("C-x C-r" . helm-recentf))
#+END_SRC

*** Desktops
Desktops allows you to save just about everything about the state of Emacs when
it closes and restore on startup. Frames, frame position, window position,
variable state, basically everything. This can be quite convenient
#+BEGIN_SRC emacs-lisp
(setq dekstop-auto-save-timeout 300)
(if (display-graphic-p)
    (desktop-save-mode nil))
(setq desktop-dirname (with-user-d "desktops")
      desktop-path (list desktop-dirname)
      desktop-auto-save-timeout 30
      desktop-save nil)
#+END_SRC

*** Flyspell
Flyspell is the spell-checking package in Emacs. Unfortunately, I don't know of
any way to use system spellcheckers in Emacs buffers (because the text here is
fundamentally not the same as an NSText window, or any Linux equivalent). Due to
that fact, I use Flyspell, the built in spell-checking framework, along with the
~ispell~ backend.
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :diminish
  :config
  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
  (defun spruce/enable-text-flyspell ()
    (flyspell-mode t))
  (setq ispell-program-name "/usr/local/bin/ispell")
  (add-hook 'text-mode-hook #'spruce/enable-text-flyspell))
#+END_SRC

*** Ediff
#+BEGIN_SRC emacs-lisp
(use-package ediff
  :init (setq-default ediff-highlight-all-diffs t)
  :config
  (customize-set-variable 'ediff-window-setup-function #'ediff-setup-windows-plain)
  (customize-set-variable 'ediff-split-window-function #'split-window-horizontally))
#+END_SRC
** Misc Packages
This section is for a variety of packages that are pretty small or otherwise
don't seem like they need their own section in General.

This adds a local directory for any .el files not on MELPA or packages I write
myself.
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-directory-list  (concat spruce/org-config-dirpath "/packages/"))
#+END_SRC

*** undo-tree
One of the more critical packages I use (albeit small and pretty simple). The
idea is pretty simple, but powerful. In many applications, if you make a change
to a file (change A), undo that change, and then make any other change (change
B), then change A is lost forever. The "history state" is simply a chain. You
can move forward and backwards along the chain (undo and redo), but if you
modify the chain (by introducing a new change while at some point in the chain
besides the tip/head), you lose all references to those existing "links".

undo-tree fixes this. Instead of a chain, the undo state is a tree. If you undo
a change, and then make some further modification, that creates a "branch
point". Then later, you can undo to that branch point and redo into the old
branch.

It's somewhat like making every file an automatic Git repo, with every change
automatically being a commit, and branching/reverting happening automatically
with undo and redo.

It might seem like this would make most normal undo/redo workflows
unnecessarily. However it doesn't, you can use undo and redo commands totally as
normal. This is because there's a concept of "active branches". If you make a
new branch, that becomes the active branch for its branch point. If you undo
through that branch point and then redo, you automatically follow the active
branch.

If you want to select a different branch, you use the visual view of history,
which shows every "change point" and "branch point", along with the option do
show what each point changes etc. And of course navigate through the changes.

Additionally, you can save this undo state to disk, to keep it persistently.

Once I got used to this package I ended up using it far more than I expected.
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (setq undo-tree-auto-save-history t)
  (add-to-list 'undo-tree-history-directory-alist
               `("." . ,(with-user-d "filedata" "undo")))
  (global-undo-tree-mode))
#+END_SRC

*** Persistent Scratch
I don't use =*scratch*= too often these days, but when I do, I generally want the
contents to stick around through restarts. I lost a reasonable amount of
relevant information due to carelessness before installing this package.
#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :config (persistent-scratch-setup-default))
#+END_SRC

*** transpose-frame
A simple package that allows for transposing the windows in a frame (i.e.
swapping the "rows" and "columns" of the windows). It also includes a few other
window-manipulation functions, such as flip-frame etc. In general it's quite
useful when trying to obtain a specific window arrangement quickly.
#+BEGIN_SRC emacs-lisp
(use-package transpose-frame)
#+END_SRC

*** buffer-move
Similar to ~transpose-frame~, except allowing for the movement of a single window
(or rather, the buffer in that window), up/down/left/right. I don't currently
have keybindings for this, and don't use it much, but that may change in the
future.
#+BEGIN_SRC emacs-lisp
(use-package buffer-move)
#+END_SRC

*** xscheme
A package for using MIT Scheme in an Emacs buffer as a REPL/inferior "shell".
#+BEGIN_SRC emacs-lisp
(use-package xscheme)
#+END_SRC

*** Smartparens
This is the s-expression manipulation package I use. It includes a variety of
extensions to the default methods of manipulating expressions, and support for
treating many many kinds of "paired" objects as s-expressions (including many
LaTeX entities).
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :config
  (require 'smartparens-config)
  (smartparens-global-mode t)
  ;; There's several modes in which I usually prefer strings to be treated
  ;; similar to s-expressions. In others its less relevant/string literals are
  ;; less common.
  (setq sp-navigate-consider-stringlike-sexp
        (append sp-navigate-consider-stringlike-sexp (list 'python-mode
                                                           'org-mode
                                                           'coffeescript-mode)))
  ;; This overlay ended up being on basically all the time and overriding my
  ;; syntax highlighting. More distracting than helpful.
  (setq sp-highlight-pair-overlay nil)
  ;; Smartparens escapes quotes inside quotes to avoid "breaking the structure".
  ;; I can see the motivation, but this just always ends up being annoying.
  (setq sp-escape-quotes-after-insert nil)
  :bind (("C-M-f" . sp-forward-sexp)
         ("C-M-b" . sp-backward-sexp)
         ("C-M-u" . sp-backward-up-sexp)
         ("C-M-d" . sp-down-sexp)
         ("C-M-a" . sp-backward-down-sexp)
         ("C-M-e" . sp-forward-up-sexp)
         ("C-M-n" . sp-beginning-of-next-sexp)
         ("C-M-p" . sp-beginning-of-previous-sexp)
         ;; Unwrap, or remove the parens/outer pair from the current s-exp
         ("C-M-<backspace>" . sp-unwrap-sexp))) 
#+END_SRC

*** Aggressive Indent
A lot of the time, I prefer things to happen automatically as I type.
Autocorrect, inserting matching parens/brackets, etc. So when it's possible,
automatically indenting code as I type and make modifications is preferable.
Aggressive indent does this, including automatically shifting code when blocks
are added or removed, or automatically moving lower columns if you change the
indent of higher ones.

The problem is, this effectively takes over indentation completely. If for some
reason the config isn't set up correctly/perfectly in some situation, manually
correcting it is annoying and prone to getting reverted as soon as you press
enter. Additionally it doesn't work very well in whitespace-based languages such
as Python.

But in concept this is what I would prefer, and sometimes I enable it.
#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :config
  (defun spruce/enable-aggressive-indent ()
    (interactive)
    (aggressive-indent-mode t))
  (defun spruce/disable-agressive-indent ()
    (interactive)
    (aggressive-indent-mode nil))
  ;; Aggressive indent works best in C-like modes
  (add-hook 'cc-mode-hook #'spruce/enable-aggressive-indent))
#+END_SRC

*** Indent Guides
Deep nesting is often a sign of poor design, but in other situations it's
unavoidable or temporarily the best option. Regardless, it's almost always
somewhat difficult to understand and keep in working memory. Indent guides make
sure you know which indentation level a given line of code is at a glance,
regardless of the syntax or number of spaces per indentation level.

On the other hand, this package is somewhat buggy and doesn't look quite
perfect. If I needed it more I'd put in the work to fix it. For now, it's here
but not enabled by default in any modes.
#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :config
  (setq highlight-indent-guides-method 'character))
#+END_SRC

*** DTRT Indent
This package contains a minor mode that will automatically figure out what
preferences were used in the creation of an existing source file and temporarily
adjust Emacs' settings to match. This allows for much easier collaborative
editing, or dealing with multiple projects with different conventions. It can
become problematic when trying to /fix/ poor style choices however.
#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent)
#+END_SRC

** Fun
This section is for various fun or ridiculous packages/games.
*** Achievements Mode
Achievements is a fun little package that keeps track of your actions in Emacs
and awards achievements when certain conditions are met. Some are good, some are
bad, some are mutually exclusive. I hope to get a good number of them over time.
#+BEGIN_SRC emacs-lisp
(use-package achievements
  :defer 4
  :diminish achievements-mode
  :config (achievements-mode t))
#+END_SRC

* Programming
This is the section for heavily or exclusively programming-focused config. It
includes my config for each programming major mode (effectively language).
** Prog Mode
~prog-mode~ is the "supermode" for every programming major mode. Config here is
for anything that applies to every (or almost every) programming mode. If
there's a few modes that need to disable general functionality, this happens in
their specific sections.

*** Spacing and Indentation
In effectively all programming modes, I prefer to fit as much code as possible
in a given vertical space. So in those modes, as little spacing between lines as
possible. While I find this very slightly less pleasant to read, it's overall
worth it, and I'm used to it when reading code.
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (setq line-spacing nil)))
#+END_SRC

I use spaces, not tabs. Partially this decision is influenced by my roots in
Python, in which use of tabs is /heavily/ discouraged. But in general, it seem
pretty clear to me that consistent indentation levels is critical. If someone
writes code that stops at around 80 columns for readability, but indents with
tabs, then someone else looking at the code might see very different end
columns. Especially on GitHub, where each tab is 8 spaces. Beyond that, various
forms of manual vertical alignment that improve readability can be ruined if
variable-width tabs are included. The advantages of tabs seem to be slightly
smaller source size and the ability for programmers to choose their indentation
level when this doesn't interfere with readability. Overall, I think spaces win.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

On the other hand, some files do have tabs (why, Makefiles, why). And in those
cases, 8 spaces is far too much for "one conceptual indentation level".
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
#+END_SRC

*** TODO Commenting
This function and keybinding basically do exactly what I want for commenting.
Apparently there's some shiny new options in Emacs 25 that I should probably
replace this with. Credit: [[https://lists.gnu.org/archive/html/emacs-devel/2008-12/msg00390.html][Will Farrington]].
#+BEGIN_SRC emacs-lisp
(defun comment-dwim-line (&optional arg)
  "Replacement for the comment-dwim command.
   If no region is selected and current line is not blank and we are
   not at the end of the line, then comment current line.
   Replaces default behaviour of comment-dwim, when it inserts
   comment at the end of the line."
  (interactive "*P")
  (comment-normalize-vars)
  (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
      (comment-or-uncomment-region (line-beginning-position) (line-end-position))
    (comment-dwim arg)))
(bind-key "M-;" #'comment-dwim-line)
#+END_SRC

** CC Mode
In Emacs, ~cc-mode~ is the base mode for editing many C-like modes, including C
and C++, but also Java, Objective-C, and AWK. There's some preferences I have
that apply pretty universally to C-like modes, and those go here.

This is the base package location in which config is nowebbed into.
#+BEGIN_SRC emacs-lisp :noweb tangle
(use-package cc-mode
    :config
    <<cc-style-config>>
    ;; Usually want dtrt-indent in CC-mode files, due to the massive number of
    ;; different styles you can come across
    (with-eval-after-load 'dtrt-indent
      (add-hook 'c-mode-common-hook
              (lambda () (dtrt-indent-mode t))))
    :bind (:map c-mode-base-map
           ;; Compiling within Emacs is pretty critical, and a massive
           ;; productivity boost over using a separate terminal
           ("C-c b" . compile)))
#+END_SRC

The CC style is a set of variable values that control things such as
indentation, tab use, commenting, argument alignment etc. I prefer Python-style
C, with some variants.
#+BEGIN_SRC emacs-lisp :noweb-ref cc-style-config :tangle no
(c-add-style "spruce-style"             ; I call my style spruce-style
             '("python"                 ; inherit from the python style
               (indent-tabs-mode . nil) ; except never use tabs
               (c-basic-offset . 4)     ; and use a smaller offset interval
               (fill-column . 80)))     ; and start filling a few characters later
;; Sets this as the default style for all cc-mode buffers
(setq c-default-style "spruce-style")
#+END_SRC

*** CC Mode utility functions
These are functions that are useful across many CC-derived modes.

Astyle is a program that automatically styles a buffer. This simply calls that
(external) program on the current buffer.
#+BEGIN_SRC emacs-lisp
(defun astyle-this-buffer (pmin pmax)
  (interactive "r")
  (shell-command-on-region pmin pmax
                           "astyle" ;; add options here...
                           (current-buffer) t
                           (get-buffer-create "*Astyle Errors*") t))
#+END_SRC

*** C++
This is the location for C++ specific configuration.

Currently the only such config I have is a lower number of spaces per
indentation level. This is because C++ tends to get quite nested, quite fast.
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook (lambda () (setq c-basic-offset 2)))
#+END_SRC

*** C
This is the location for C specific configuration. Currently I have no such
config. If I work more extensively with C in the future it is likely to appear.

** Python
Python is, and has been for many years, my most used language. Whether it's my
favorite is more in question (more functional and typed languages are
encroaching), but nevertheless it's an important major mode.

#+BEGIN_SRC emacs-lisp :noweb tangle
(use-package python
  :config
  <<python-utility-functions>>
  <<jedi-config>>
  <<python-shell-config>>
  :bind (:map python-mode-map
         ;; I use this keybinding to toggle "breakpoints" in Python code
         ("C-c C-d" . toggle-pdb)))
#+END_SRC

*** Jedi Config
Jedi is an autocompletion and semantic analysis framework for Python. In fact,
it's totally separate from Emacs, and can be used "plug-n-play" in a variety of
situations. But here, I use it as a Company backend for Python, and as a way to
do a few "IDE-like" tasks.
#+BEGIN_SRC emacs-lisp :noweb-ref jedi-config :tangle no
(use-package jedi
  :config
  ;; Automatically start completion on property access
  (setq jedi:complete-on-dot t)
  (defun jedi-python-mode-hook-add-company ()
    (add-to-list 'company-backends 'company-jedi))
  (add-hook 'python-mode-hook #'jedi-python-mode-hook-add-company)
  :bind (:map python-mode-map
         ("C-c /" . jedi:show-doc)
         ("C-c ." . jedi:goto-definition)))
#+END_SRC

*** Python Shell Config
The Python REPL buffer can be extremely useful for quick development and
testing. I'm a Python 3 guy, so I use that. The "-i", interactive flag, tries to
ensure the interpreter uses prompts even if it thinks it's being called
non-interactively.
#+BEGIN_SRC emacs-lisp :noweb-ref python-shell-config :tangle no
(setq python-shell-interpreter "python3"
      python-shell-interpreter-args "-i")
#+END_SRC

*** Python Utility Functions
Here is for any Python-specific utility functions I write or "borrow" from
others.
#+BEGIN_SRC emacs-lisp :noweb-ref python-utility-functions :tangle no
;; Written by Spruce Bondera
(defun toggle-pdb ()
  "Toggles a breakpoint line at the current point location,
handling the case where there's code at the point"
  (interactive)
  (let ((line (s-trim (thing-at-point 'line t)))
        (debug "import ipdb; ipdb.set_trace()"))
    (cond ((equal line debug)
           (kill-whole-line)
           (previous-line)
           (move-end-of-line 1))
          (t (python-nav-end-of-statement)
             (cond ((equal line "")
                    (insert debug))
                   ((not (equal (length line) 0))
                    (move-end-of-line 1)
                    (newline-and-indent)
                    (insert debug)))))))
#+END_SRC

** Emacs Lisp
The config for Emacs Lisp mode. I'm largely fine with the defaults (augmented by
Smartparens of course). However, since Emacs is an elisp-machine, it is nice to
be able to run the current buffer easily.
#+BEGIN_SRC emacs-lisp
(use-package emacs-lisp-mode
  :ensure nil
  :bind (:map emacs-lisp-mode-map
         ("H-e" . eval-buffer)))
#+END_SRC

** Coffeescript
Coffeescript is one of many languages that compiles to Javascript. Generally, I
regard it as a "Pythonization" (or maybe more "Rubyization") of Javascript.
However, since I've used Coffeescript much more than I ever have Javascript, I
can't make particularly intelligent comparisons. From what I've heard, most of
the utility has been replaced by ES6 (although still with less bracey syntax).
But I keep the mode around due to past usage.
#+BEGIN_SRC emacs-lisp
(use-package coffee-mode
  :config
  (setq coffee-tab-width 2))
#+END_SRC

** Haskell
Haskell, the pure functional language. One of few, and one of the most well
known functional language in some practical use. Also known for the inclusion of
concepts from category theory, such as monads (although these are somewhat
different from the actual mathematical definitions).

I enjoy learning and using Haskell, although I remain a definite novice. To me,
it has a similar feel as my summer learning J many years ago, in that difficult
concepts compose with great power, and short cryptic lines hold implausible
amounts of meaning. However the difference is, it's much easier to see the
practical utility in Haskell, and indeed make use of it.

The type system is by far sufficient for me to be happy using it (unlike say,
Java, C, and C++-before-concepts). The built in library is pretty seriously
extensive. There's a large ecosystem, although it's made up of the kind of
people who like programming in Haskell, so there's often not one clear best
choice.

I'll add more to this section as I gain more experience and am more confident in
the validity of my opinions. For now it seems like the most promising avenue for
me, PL-wise.

I've not got much config here at the moment. Just the major mode and Intero.
Intero includes Flycheck support and a REPL buffer, etc. More of a complete IDE
experience. As I use Haskell more, more preferences will accumulate.
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode)
(use-package intero
  :config
  (add-hook 'haskell-mode-hook 'intero-mode))
#+END_SRC

* Org
#+BEGIN_SRC emacs-lisp
(use-package org
  :diminish org-indent-mode
  :config
  (setq org-startup-indented t)
  (let ((file-list (list (with-user-d-s "emacs-todo.org"))))
    (when (string-equal system-name "spruce-machine")
      (add-to-list 'file-list "~/Documents/Classes/school-schedule.org"))
    (setq org-agenda-files file-list))
  (setq org-bullets-bullet-list (list "●" "●" "○" "○" "○" "○" "○" "○" "○" "○" "○" "○" "○"))
  (setq org-export-backends '(ascii html icalendar latex md))
  (setq org-fontify-whole-heading-line t)
  (setq org-pretty-entities t)
  (setq org-list-allow-alphabetical t)
  (setq org-highlight-latex-and-related '(latex script entities))
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((R . t)
     (emacs-lisp . t)
     (python . t)
     (sh . t)
     (latex . t)
     (haskell . t)))
  (setq org-hide-leading-stars t)
  (set-face-attribute 'org-hide nil :foreground (face-attribute 'default :background))
  (setq org-src-preserve-indentation nil
        org-edit-src-content-indentation 0)
  (setq org-confirm-babel-evaluate nil
        org-src-fontify-natively t
        org-src-tab-acts-natively t)
  (setq org-archive-location (with-user-d-s "%s-archive::" "org" "archive"))
  (setq org-startup-folded 'content)
  ;; in org mode C-a/e moves to beginning of text in line, after header asterisks
  ;; however you can press it again to go all the way
  (setq org-special-ctrl-a/e t)
  ;; don't display slashes/asterisks etc for italics/bold etc
  (setq org-hide-emphasis-markers t)
  (setq org-fontify-done-headline t
        org-fontify-quote-and-verse-blocks t)
  (setq org-startup-truncated nil)
  (add-hook 'org-mode-hook (lambda () (setq line-spacing '0.25)))
  (setq org-use-sub-superscripts "{}")
  (setq org-export-headline-levels 5)
  (setq org-export-with-section-numbers nil)
  (setq org-export-with-tags nil)

  (setq org-src-ask-before-returning-to-edit-buffer nil)
  (setq org-src-window-setup 'current-window)
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" ""))
  (add-to-list 'org-structure-template-alist
               '("la" "#+BEGIN_SRC LaTeX\n?\n#+END_SRC" ""))
  (add-to-list 'org-structure-template-alist
               '("ha" "#+BEGIN_SRC haskell\n?\n#+END_SRC" ""))
  (add-to-list 'org-structure-template-alist
               '("py" "#+BEGIN_SRC python\n?\n#+END_SRC" ""))
  (setq spruce/org-css-file
        (concat (concat-directories spruce/org-config-dirpath "css")
                "org-export.css"))
  (setq org-html-head-extra
        (concat "<style type=\"text/css\">"
                (with-temp-buffer
                  (insert-file-contents spruce/org-css-file)
                  (end-of-buffer)
                  (insert ".src {\n    background-color: "
                          (face-attribute 'default :background)
                          ";\n   color: "
                          (face-attribute 'default :foreground)
                          ";\n}")
                  (buffer-string))
                "</style>"))
  (defun spruce/org-cycle-current-subtree ()
    (interactive)
    (let ((old-tab-style org-cycle-emulate-tab))
      (setq org-cycle-emulate-tab nil)
      (org-cycle)
      (setq org-cycle-emulate-tab old-tab-style)))

  (defun spruce/org-clock-select ()
    (interactive)
    (org-clock-in '(4)))

  (setq org-log-into-drawer t)
  (with-eval-after-load 'latex
    (bind-key "H-C-j" #'spruce/LaTeX-insert-inline-math
              org-mode-map)
    (bind-key "H-C-k" #'spruce/LaTeX-insert-display-math
              org-mode-map))
  (with-eval-after-load 'ox-beamer
    (add-to-list 'org-beamer-environments-extra
                 '("onlyenv" "O" "\\begin{onlyenv}%a" "\\end{onlyenv}")))
  (customize-set-variable 'org-tags-column -60)
  ;; Set the Org ellipsis
  (set-display-table-slot standard-display-table 
                        'selective-display (string-to-vector " ➢"))
  ;; ➤ ▼ ➢ ⤵ ↴ ⬎ ⤷ ͢

  :bind (("C-c a" . org-agenda)
         ("C-c l" . org-store-link)
         ("C-c o c" . org-capture)
         ("C-c o i" . spruce/org-clock-select)
         ("C-c o o" . org-clock-out)
         ("C-c b" . org-iswitchb)
         ("C-c L" . org-insert-link-global)
         ("C-c o C-o" . org-open-at-point-global)
         ("H-M-<return>" . org-insert-subheading)
         :map org-mode-map
         ("C-<tab>" . spruce/org-cycle-current-subtree)))

(use-package org-bullets
  :config
  (add-hook 'org-mode-hook
            (lambda () (org-bullets-mode 1)))
  (setcdr org-bullets-bullet-map nil))
#+END_SRC

* LaTeX
#+BEGIN_SRC emacs-lisp
(use-package tex
  :ensure auctex
  :defer 5
  :config
  ;; TODO: fucks up prettify for some reason?
  ;; (company-auctex-init)
  ;; save buffer style info
  (setq TeX-auto-save t)
  ;; automatically parse style info
  (setq TeX-parse-self t)
  ;; no tabs
  (setq TeX-auto-untabify t)
  ;; TODO: unsure what this does
  ;; (setq-default TeX-master 'dwim)
  (setq TeX-PDF-mode t)
  (defun spruce/TeX-open-output-buffer ()
    (interactive)
    (let ((output-file (with-current-buffer TeX-command-buffer
                         (expand-file-name
                          (TeX-active-master (TeX-output-extension))))))
      (find-file output-file)))
  (add-to-list 'TeX-view-program-list
               (list "Emacs" #'spruce/TeX-open-output-buffer))

  (setq TeX-view-program-selection '((output-pdf "Emacs")))
  ;; better name for local variable
  (defun latex-compile ()
    (interactive)
    (save-buffer)
    (TeX-command "LaTeX" 'TeX-master-file))

  (setq TeX-auto-local ".auctex-auto")
  ;; auto revert pdf buffer
  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer)
  ;; show errors if there were any
  (setq TeX-error-overview-open-after-TeX-run t)
  ;; don't confirm before cleaning files
  (setq TeX-clean-confirm nil)
  (setq TeX-save-query nil)
  (defun TeX-insert-pair (arg open-str close-str)
    "Like TeX-insert-brackes but for any pair"
    (interactive "P")
    (if (TeX-active-mark)
        (progn
          (if (< (point) (mark)) (exchange-point-and-mark))
          (insert close-str)
          (save-excursion (goto-char (mark)) (insert open-str)))
      (insert open-str)
      (save-excursion
        (if arg (forward-sexp (prefix-numeric-value arg)))
        (insert close-str))))
  (setq TeX-electric-sub-and-superscript t)
  (put 'TeX-command-extra-options 'safe-local-variable
       (lambda (x) (string-equal x "-shell-escape")))
  (setq-default TeX-command-extra-options "-shell-escape")
  (use-package latex
    :ensure nil
    :config
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (setq LaTeX-math-menu-unicode t)
    (add-hook 'LaTeX-mode-hook (lambda () (latex-electric-env-pair-mode t)))
    (add-hook 'LaTeX-mode-hook
              (lambda () (set-fill-column 90)))
    (add-hook 'LaTeX-mode-hook 'turn-on-auto-fill)
    (add-hook 'LaTeX-mode-hook (lambda () (prettify-symbols-mode)))
    (defun spruce/LaTeX-insert-inline-math (arg)
      (interactive "P")
      (TeX-insert-pair arg "\\( " " \\)"))
    (defun spruce/LaTeX-insert-display-math (arg)
      (interactive "P")
      (TeX-insert-pair arg "\\[ " " \\]"))

    (defun spruce/LaTeX-insert-problem (problem-number &optional is-last)
      (beginning-of-line)
      (let ((problem (concat "\\problem{" problem-number "}"))
            (unfinished "\\unfinished{}"))
        (insert problem "\n\n" unfinished "\n"
                (if is-last "" "\n"))))

    (defun spruce/LaTeX-make-problem-list ()
      (interactive)
      (let ((data (split-string (thing-at-point 'line t))))
        (when data
          (delete-region (line-beginning-position)
                         (line-end-position))
          (mapc #'spruce/LaTeX-insert-problem (butlast data))
          (spruce/LaTeX-insert-problem (car (last data)) t))))

    (defun spruce/LaTeX-mode-keybindings ()
      (bind-key "H-C-j" #'spruce/LaTeX-insert-inline-math
                (current-local-map))
      (bind-key "H-C-k" #'spruce/LaTeX-insert-display-math
                (current-local-map))
      (bind-key "C-c x p" #'spruce/LaTeX-make-problem-list
                (current-local-map))
      (local-unset-key "\""))

    (add-hook 'LaTeX-mode-hook #'spruce/LaTeX-mode-keybindings)
    (with-eval-after-load 'smartparens
      (add-hook 'TeX-mode-hook #'smartparens-mode))
    (use-package font-latex
      :ensure nil
      :config
      (set-face-attribute 'font-latex-sedate-face nil
                          :inherit 'font-lock-constant-face
                          :foreground 'unspecified))
    :bind (:map LaTeX-mode-map
           ("C-c c" . latex-compile))))

(use-package reftex
  :diminish reftex-mode
  :config
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
  (setq reftex-plug-into-AUCTeX t))

(setq latex-templates-directory (with-user-d "templates" "latex-templates"))
(defun latex-template ()
  (interactive)
  (let* ((files (file-expand-wildcards (concat latex-templates-directory "*.tex")))
         (selection (completing-read "LaTeX Template: "
                                     (mapcar #'file-name-base files))))
    (insert-file-contents (concat latex-templates-directory selection ".tex"))))
#+END_SRC

* The Heap
Sometimes I want to test out a tweak or fix an annoyance fast, without putting
in the time to document how or why. This is a bad habit, but sometimes
necessary. The Heap is where all of that temporarily unfiled code goes.

** Tweak Heap
#+BEGIN_SRC emacs-lisp
(bind-key "C-x C-3" #'spruce/split-right-select-new)
(bind-key "C-x C-2" #'spruce/split-below-select-new)
(bind-key "C-H-q" #'ace-window)
#+END_SRC

** Package Heap
*** ebnf
#+BEGIN_SRC emacs-lisp
(use-package ebnf-mode
  :ensure nil)
#+END_SRC

*** rtags
#+BEGIN_SRC emacs-lisp
(use-package rtags
  :defer 3)
#+END_SRC

*** bison-mode
#+BEGIN_SRC emacs-lisp
(use-package bison-mode)
#+END_SRC

*** csv-mode
#+BEGIN_SRC emacs-lisp
(use-package csv-mode)
#+END_SRC

*** fireplace
#+BEGIN_SRC emacs-lisp
(use-package fireplace)
#+END_SRC

*** fish-mode
#+BEGIN_SRC emacs-lisp
(use-package fish-mode)
#+END_SRC

*** go mode
#+BEGIN_SRC emacs-lisp
(use-package go-mode)
#+END_SRC

*** EMMS
#+BEGIN_SRC emacs-lisp
(use-package emms)
#+END_SRC

*** julia mode
#+BEGIN_SRC emacs-lisp
(use-package julia-mode)
#+END_SRC

*** llvm mode
#+BEGIN_SRC emacs-lisp
(use-package llvm-mode)
#+END_SRC

*** lua mode
#+BEGIN_SRC emacs-lisp
(use-package lua-mode)
#+END_SRC

*** paradox
#+BEGIN_SRC emacs-lisp
(use-package paradox
  :config
  (setq paradox-github-token t))
#+END_SRC

*** multiple cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors)
#+END_SRC

*** projectile ripgrep
#+BEGIN_SRC emacs-lisp
(use-package projectile-ripgrep)
#+END_SRC

*** rainbow mode
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode)
#+END_SRC

*** ace window
#+BEGIN_SRC emacs-lisp
(use-package ace-window)
#+END_SRC

*** rust mode
#+BEGIN_SRC emacs-lisp
(use-package rust-mode)
#+END_SRC

*** SLIME
#+BEGIN_SRC emacs-lisp
(use-package slime)
#+END_SRC

*** pyvenv
#+BEGIN_SRC emacs-lisp
(use-package pyvenv)
#+END_SRC

*** autopep8
#+BEGIN_SRC emacs-lisp
(use-package py-autopep8)
#+END_SRC

*** Pylint
#+BEGIN_SRC emacs-lisp
(use-package pylint)
#+END_SRC

** Old Heap
#+BEGIN_SRC emacs-lisp
(setq exec-path (append exec-path '(":/usr/local/bin")))
(setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
(setq exec-path (append exec-path '(":/usr/texbin")))
(setenv "PATH" (concat (getenv "PATH") ":/usr/texbin"))

(setq doc-view-continuous t)
(setq doc-view-ghostscript-program "/usr/local/bin/gs")

(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
(add-hook 'coffeescript-mode-hook 'whitespace-mode)
(add-hook 'python-mode-hook 'whitespace-mode)
(setq whitespace-style
      '(face trailing space-before-tab tabs
             space-after-tab))
;; don't do anything whitespace, use whitespace-fn instead
(setq whitespace-action nil)

(defun whitespace-save-fn ()
  (add-hook 'before-save-hook
            'delete-trailing-whitespace-except-current-line
            nil 'local))

(add-hook 'c-mode-common-hook #'whitespace-save-fn)
(add-hook 'python-mode-hook #'whitespace-save-fn)
(add-hook 'lisp-mode-hook #'whitespace-save-fn)
(add-hook 'prog-mode-hook #'whitespace-mode)
;; (setq auto-revert-use-notify nil)

(setq whitespace-line-column 86)
(setq hl-line-sticky-flag nil)
(setq mac-ignore-momentum-wheel-events t)
#+END_SRC

* Utility Functions
These functions are bound to keys and used in various places in my config.
Functions are only here if I felt they were sufficiently general, not tied to a
specific setting. Documentation is generally provided in the docstring rather
than through =org=. This code block is not directly tangled, rather it is included
through =noweb= near the top of this file.

#+BEGIN_SRC emacs-lisp :noweb-ref utility-functions :tangle no
;; see http://ergoemacs.org/emacs/modernization_elisp_lib_problem.html
(defun s-trim-left (s)
  "Remove whitespace at the beginning of S."
  (if (string-match "\\`[ \t\n\r]+" s)
      (replace-match "" t t s)
    s))

(defun s-trim-right (s)
  "Remove whitespace at the end of S."
  (if (string-match "[ \t\n\r]+\\'" s)
      (replace-match "" t t s)
    s))

(defun s-trim (s)
  "Remove whitespace at the beginning and end of S."
  (s-trim-left (s-trim-right s)))

(defun delete-trailing-whitespace-except-current-line ()
  (interactive)
  (let ((begin (line-beginning-position))
        (end (line-end-position)))
    (save-excursion
      (when (< (point-min) begin)
        (save-restriction
          (narrow-to-region (point-min) (1- begin))
          (delete-trailing-whitespace)))
      (when (> (point-max) end)
        (save-restriction
          (narrow-to-region (1+ end) (point-max))
          (delete-trailing-whitespace))))))

;; from http://stackoverflow.com/questions/15580913/
(defun toggle-quotes ()
  (interactive)
  (save-excursion
    (let ((start (nth 8 (syntax-ppss)))
          (quote-length 0) sub kind replacement)
      (goto-char start)
      (setq sub (buffer-substring start (progn (forward-sexp) (point)))
            kind (aref sub 0))
      (while (char-equal kind (aref sub 0))
        (setq sub (substring sub 1)
              quote-length (1+ quote-length)))
      (setq sub (substring sub 0 (- (length sub) quote-length)))
      (goto-char start)
      (delete-region start (+ start (* 2 quote-length) (length sub)))
      (setq kind (if (char-equal kind ?\") ?\' ?\"))
      (loop for i from 0
            for c across sub
            for slash = (char-equal c ?\\)
            then (if (and (not slash) (char-equal c ?\\)) t nil) do
            (unless slash
              (when (member c '(?\" ?\'))
                (aset sub i
                      (if (char-equal kind ?\") ?\' ?\")))))
      (setq replacement (make-string quote-length kind))
      (insert replacement sub replacement))))

(defun move-line-up ()
  "Move up the current line."
  (interactive)
  (transpose-lines 1)
  (forward-line -2)
  (indent-according-to-mode))

(defun move-line-down ()
  "Move down the current line."
  (interactive)
  (forward-line 1)
  (transpose-lines 1)
  (forward-line -1)
  (indent-according-to-mode))

(defun revert-buffer-no-prompt ()
  "Revert buffer without confirm prompt"
  (interactive)
  (revert-buffer t t))

(defun backward-kill-line (arg)
  "Kill ARG lines backward."
  (interactive "p")
  (kill-line (- 1 arg)))

(defun spruce/split-right-select-new ()
  (interactive)
  (select-window (split-window-right)))
(defun spruce/split-below-select-new ()
  (interactive)
  (select-window (split-window-below)))

(defun spruce/make-note ()
  (interactive)
  (let ((buffer (generate-new-buffer "notes")))
    (switch-to-buffer buffer)
    (org-mode)))

(defun concat-directories (&rest directories)
  (apply 'concat (mapcar 'file-name-as-directory directories)))

(defun with-user-d (&rest directories)
  (apply 'concat-directories user-emacs-directory directories))
(defun with-user-d-s (suffix &rest directories)
  (concat (apply 'with-user-d directories) suffix))

;; delete current frame, or window if it's the last one
(defun delete-frame-or-window ()
  (interactive)
  (if (one-window-p)
      (delete-frame)
    (delete-window)))
;; go back a window in the same frame
(defun back-window ()
  (interactive)
  (other-window -1))

(defun spruce/add-dictionary-word ()
  "From https://stackoverflow.com/questions/22107182/"
  (interactive)
  (let ((current-location (point))
         (word (flyspell-get-word)))
    (when (consp word)
      (flyspell-do-correct 'save nil (car word)
       current-location (cadr word) (caddr word)
       current-location))))
#+END_SRC

