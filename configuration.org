#+TITLE: Spruce's Emacs
#+AUTHOR: Spruce Bondera
#+PROPERTY: header-args  :tangle yes
#+OPTIONS: toc:nil
* About
This file, and the others it references, contain my Emacs configuration. I've
been using Emacs since around 2014, and using it heavily since mid-2015. Over
the course of the next year and a half I accumulated a serious amount of config
and packages of various forms. Emacs is software with a hilariously high
potential ceiling (I haven't caught a glimpse of it yet), but in my view pretty
terrible defaults. A large part of my switch to fully using it was due to
accumulating the critical mass of configuration necessary to use it without
significant annoyance.

It's easy to just throw config in your =.emacs= or =init.el=, which is
what I did for over a year and a half. However at a certain point it accumulates
cruft, competing and contradictory code, becomes impossible to search through,
and even worse to debug. It's pretty common in the Emacs community to deal with
this through literate programming through =org-mode=. The code becomes somewhat
secondary to documentation and organization, making it easier to keep track of
and modify. This is my ongoing attempt to organize, clean up, and improve my
config. Started October 15th, 2016.
* Contents                                                        :TOC_2_org:
 - [[About][About]]
 - [[Bootstrap][Bootstrap]]
   - [[Security][Security]]
   - [[Configuration Management][Configuration Management]]
   - [[Personal Information][Personal Information]]
   - [[Utility Functions][Utility Functions]]
   - [[Default Settings][Default Settings]]
   - [[Keybindings][Keybindings]]
   - [[Basic Appearance][Basic Appearance]]
   - [[macOS][macOS]]
 - [[General][General]]
   - [[Helm][Helm]]
   - [[Projectile][Projectile]]
   - [[Company][Company]]
   - [[Appearance][Appearance]]
   - [[Modes][Modes]]
   - [[Packages][Packages]]
   - [[IRC][IRC]]
   - [[Misc][Misc]]
 - [[Programming][Programming]]
   - [[=prog=][=prog=]]
   - [[CC][CC]]
   - [[Python][Python]]
   - [[Emacs Lisp][Emacs Lisp]]
   - [[Coffeescript][Coffeescript]]
 - [[Org][Org]]
 - [[LaTeX][LaTeX]]
 - [[The Heap][The Heap]]
   - [[Package Heap][Package Heap]]
   - [[Old Heap][Old Heap]]
 - [[Utility Functions][Utility Functions]]

* Bootstrap
** Security
There are several important security improvements to Emacs that should come as
early a possible in config, to prevent inevitable network connection attempts
from being hilariously insecure
*** TLS
Much of the following is credited to [[https://glyph.twistedmatrix.com/2015/11/editor-malware.html][Glyph]].

~network-security-level~ sets how careful Emacs is with network security. The
default is =medium=, but I prefer =high=, as it prevents a few more problematic
practices. =paranoid= is a little far for me though.
#+BEGIN_SRC emacs-lisp
(setq network-security-level 'high)
#+END_SRC

However this only matters in Emacs 25 and higher. For older versions, network
connections are not secure by default at all. This enables TLS checking.

#+BEGIN_SRC emacs-lisp
(setq tls-checktrust t)
#+END_SRC

All of the above only applies to Emacs not built with an external TLS checker.
However if it is built with one like GnuTLS, some extra config is necessary.

#+BEGIN_SRC emacs-lisp
(let ((trustfile
       (replace-regexp-in-string
        "\\\\" "/"
        (replace-regexp-in-string
         "\n" ""
         (shell-command-to-string "python -m certifi")))))
  (setq tls-program
        (list
         (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                 (if (eq window-system 'w32) ".exe" "") trustfile)))
  (setq gnutls-verify-error t)
  (setq gnutls-trustfiles (list trustfile)))
#+END_SRC

This ensures that TLS is configured correctly, and prevents further config
evaluation otherwise. Currently disabled for speed.

#+BEGIN_SRC emacs-lisp :tangle no
(let ((bad-hosts
       (loop for bad
             in `("https://wrong.host.badssl.com/"
                  "https://self-signed.badssl.com/")
             if (condition-case e
                    (url-retrieve
                     bad (lambda (retrieved) t))
                  (error nil))
             collect bad)))
  (if bad-hosts
      (error (format "tls misconfigured; retrieved %s ok"
                     bad-hosts))
    (url-retrieve "https://badssl.com"
                  (lambda (retrieved) t))))
#+END_SRC

** Configuration Management
*** =use-package=
I use the =use-package= package [[https://github.com/jwiegley/use-package][(here)]] to configure both Emacs and the large
number of other packages I use.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(require 'use-package)
;; All packages in a use-package macro should be automatically installed
(setq use-package-always-ensure t)
#+END_SRC
Additionally, I use the ~:diminish~ feature of =use-package= to hide various minor
modes from my mode line.
*** TODO =validate=
=validate= is a package that tries to minimize invalid variable values. Emacs and
many packages have user-configurable variables that should only hold certain
values, perhaps only integers or only one of a list of symbols. It's possible to
subtly mis-configure these, potentially letting Emacs to continue to run until
some feature is called and behaves wildly unexpectedly. So I use =validate= and
~validate-setq~ whenever possible.
#+BEGIN_SRC emacs-lisp
(use-package validate)
#+END_SRC

*** External Files
I have several external config files loaded by this one. These are given
variable names and added to a global list in various sections in this file. To
do this I use the following macro and list:

#+BEGIN_SRC emacs-lisp
(setq-default spruce/org-config-directory "literate")
(setq-default spruce/org-config-dirpath
              (expand-file-name (concat user-emacs-directory
                                        spruce/org-config-directory)))
(add-to-list 'load-path spruce/org-config-dirpath)
(setq-default spruce/config-org-files nil)

;; transforms the given name to "spruce/name-config-file" and sets it
;; to the given org filename
(defmacro spruce/new-config-file (name filename)
  (let ((full-file (make-symbol "full-filename")))
    `(let ((,full-file
            (concat spruce/org-config-dirpath "/" ,filename ".org")))
       (defvar ,(intern (concat "spruce/" (symbol-name name) "-config-file"))
         ,full-file)
       (add-to-list
        (quote spruce/config-org-files) (quote (,name . ,filename)) t))))
#+END_SRC

*** =customize=
Emacs has a built-in customization interface which auto-inserts code into your
init file. This is useful for many people and makes it pretty easy to discover
and configure settings, but I generally don't use it anymore and dislike the
undocumented format. However sometimes these settings still crop up, so I dump
them in a file and eventually configure them correctly.
#+BEGIN_SRC emacs-lisp
(setq custom-file (concat spruce/org-config-dirpath "/temp-custom.el"))
(load-file custom-file)
#+END_SRC

*** Table of Contents
While =org= exports nice tables of contents by default, they don't appear directly
in org files, and GitHub doesn't render them. So I use a package that (somewhat
worryingly) automatically inserts a table of contents into the actual org file.
#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :config
  (add-hook 'org-mode-hook 'toc-org-enable))
#+END_SRC

** Personal Information
My name and primary email for use in various other places.
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Spruce Bondera"
      user-mail-address "sprucebondera@gmail.com")
#+END_SRC

** Utility Functions
I have a number of functions not particularly tied to a specific mode or
feature-set. Many of them were defined exclusively to be accessible through a
keybinding, however if I deem them sufficiently general they get put in the
Utility Functions section, and included up here. These functions are in fact
defined at the bottom of this file, but are accessible to all config below this point.
#+BEGIN_SRC emacs-lisp :noweb tangle :exports none
<<utility-functions>>
#+END_SRC

** Default Settings
*** Modernization
Emacs is very old, and has a number of defaults that reflect this age. Some of
these I like, many I don't.

It's normal text editing behavior to automatically replace selected text if a new
character is typed.
#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

In Fundamental mode, use a single spaces after sentence-ending periods. Double
spaces are from the typewriter period and should not be used in modern documents.
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
Emacs is user-level software, not a shell, so some protection is nice. Using
a Trash is one such protection I occasionally still appreciate.
#+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash t)
#+END_SRC
Like some terminal emulators, graphical Emacs clients resize "line/column"-wise
by default (i.e. snapping to the nearest line or column). In theory this could
be useful, but it's wildly unexpected and odd looking in modern systems. This
setting tries to make "frames" (Emacs' term for windows) resize normally.
#+BEGIN_SRC emacs-lisp
(setq frame-resize-pixelwise t)
#+END_SRC

*** Parentheses Highlighting
Highlight corresponding parentheses if the cursor is over one of them. This is
pretty important in most languages, especially with the S-expression
manipulations I often perform.
#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0)
(show-paren-mode t)
#+END_SRC

*** Scratch buffer
I prefer a blank scratch buffer. The default message is just going to be deleted
anyway. In the future I may set some more complicated and useful programmatic
message as the default, but for the moment an empty buffer is the most useful
option.
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message "")
#+END_SRC

*** Backups
I have plenty of disk space, so as many backups as possible is great. However I
definitely don't want them cluttering up random directories.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
      backup-by-copying t    ; Don't delink hardlinks
      version-control t      ; Use version numbers on backups
      delete-old-versions 'never)
#+END_SRC

Additionally I want to autosave early and often, but not cause clutter.
#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms
      `((".*" "/Users/spruce/.emacs.d/autosaves" t)))
(setq auto-save-interval 100) ; 100 characters
(setq auto-save-timeout 10)   ; or 10 seconds
#+END_SRC

*** ~kill-line~
By default =C-k= or ~kill-line~ doesn't truly delete the line, but rather kill
all the text on it while leaving the newline. There are situations where this is
useful, but overall I prefer deletion of the entire line.
#+BEGIN_SRC emacs-lisp
(setq kill-whole-line t)
#+END_SRC
I also appreciate having the ability to kill backwards easily.
#+BEGIN_SRC emacs-lisp
(bind-key "H-<backspace>" 'backward-kill-line)
#+END_SRC

*** Garbage Collection Performance
The default garbage collection of Emacs is quite aggressive. It collects garbage
after around 800KB of allocation. This is tiny for modern systems. However even
though I usually have >= 16GB of RAM, setting the garbage collection threshold
too high leads to occasional but very noticeable pauses as large swaths of
memory are reclaimed. I think 100MB is a pretty reasonable balance, but I may
tweak this in the future.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 100000000)
#+END_SRC

*** =fill-column=
I generally like to fill (i.e. redistribute line breaks to not go past a certain
point) my text and code, to make it easier to browse in various situations and
edit in multiple frames. I tend towards 80 characters in free text, and a loose
80 in code (some lines are much less readable if broken up purely for consistency).
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC

*** Scrolling Context Jumps
When paging down I tend to lose track of what I was reading unless some of the
previous page remains. A full half-screen is a little much, but around 4 lines
is usually enough for me to keep my bearings.
#+BEGIN_SRC emacs-lisp
(setq next-screen-context-lines 5)
#+END_SRC

*** Mark Ring
The mark ring contains information about where marks (selection points) were
set. Since I have a modern computer I see no reason for this to be small.
#+BEGIN_SRC emacs-lisp
(setq global-mark-ring-max 200)
(setq mark-ring-max 100)
#+END_SRC
Also, I like to be able to pop repeatedly more easily.
#+BEGIN_SRC emacs-lisp
(setq set-mark-command-repeat-pop t)
#+END_SRC

*** Unicode
UTF-8 is pretty much the standard everywhere now. Better yet, unless I
specifically add "special" (non-ASCII) characters to a buffer, UTF-8 is
identical to ASCII, which is nice for compatibility with older programs.
#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq default-buffer-file-coding-system 'utf-8)
#+END_SRC

**** TODO Double check the ~set-terminal-coding-system~ portability

*** Enabling "dangerous" commands
There's a number of commands that Emacs considers potentially destructive or
dangerous for new users. I honestly think that in general this is a good
feature, but it can be annoying at times. Here I enable several of these
dangerous functions that I both understand and use.
#+BEGIN_SRC emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
#+END_SRC

In the same vein, when editing a symlinked and version controlled file (i.e.
opening a symlink to a file in version control) by default Emacs double checks
that this is in fact what you want to do, since various issues can arise if you
don't follow the link. I don't have any situations where I don't want to follow
said links, and it's less nagging.
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC
*** Debug on error
There are a lot of things that can go wrong in Emacs, especially with as much
config as I've got here. Fixing them is of course important, but the default
behavior is to immediately throw you into a debugger. I prefer to
just get a message and handle it on my own terms.
#+BEGIN_SRC emacs-lisp
(setq debug-on-error nil)
#+END_SRC

*** Visual Bell
Emacs sends "bells" relatively often (i.e. every time ~keyboard-quit~ is called).
Playing an actual sound for these gets really annoying really fast. However
using the "normal" setting of ~visable-bell~ true has caused odd problems on macOS
in the past. So for the time being I simply override the function that's meant
to play the bell sound with flashing the mode line for a tenth of a second.
#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
(setq ring-bell-function
      (lambda () (invert-face 'mode-line)
        (run-with-timer 0.1 nil 'invert-face 'mode-line)))
#+END_SRC

*** Yes or no
There's a lot of yes or no prompts in Emacs, some of which I specifically enable
to keep myself from making mistakes. However I feel confident enough in my own
competence to press =y= or =n= rather than a full =yes= or =no=.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Keybindings
*** Config File Access
Quickly getting to my config file is important for fluid customization. Just as
programming and discovery is faster with a REPL. Emacs is really just one large
REPL, so I make it easier to use as such.
#+BEGIN_SRC emacs-lisp
(defun spruce/open-config-file ()
  (interactive)
  (find-file (or spruce/bootstrap-org-path
                 user-init-file "")))
(bind-key "C-c e" 'spruce/open-config-file)
#+END_SRC

Similarly I like to be able to quickly re-eval my entire config. This involves
evaling my init file, rather than this file.
#+BEGIN_SRC emacs-lisp
(defun spruce/eval-config ()
  (interactive)
  (load-file user-init-file))
(bind-key "H-C-e" 'spruce/eval-config)
#+END_SRC

*** Quick Fullscreen Mode
#+BEGIN_SRC emacs-lisp
(bind-key "H-<return>" 'toggle-frame-fullscreen)
#+END_SRC

*** Line Shifting
Occasionally I like to shift whole lines up and down through a buffer. These
make it easier and more natural than killing and yanking.
#+BEGIN_SRC emacs-lisp
(bind-keys ("M-S-<up>" . move-line-up)
           ("M-S-<down>" . move-line-down))
#+END_SRC

*** Buffer Reversion
I find myself needing to revert buffers weirdly often. I now try to solve this
with ~auto-revert-mode~ as much as possible, but this is still helpful.
#+BEGIN_SRC emacs-lisp
(bind-key "H-r" 'revert-buffer-no-prompt)
#+END_SRC

*** Macro Recording
It took me a while to understand and get used to the idea of keyboard macros.
Especially since they interact oddly with packages such as Helm. However once I
did start using them I found defining a slightly more memorable syntax helpful.
#+BEGIN_SRC emacs-lisp
(bind-keys ("M-[" . kmacro-start-macro)
           ("M-]" . kmacro-end-macro))
#+END_SRC

** Basic Appearance
These are simple changes to the default settings.

*** Useless Information
The tool bar is both useless and ugly. Same for the scroll bar. Disable both.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

Additionally, I dislike the startup message. The logo is ancient, and after
seeing it a few times the message is irrelevant. I use =desktop-mode=, but in the
situations where I do start from scratch, I prefer to start in =*scratch*=.
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC

*** Cursor
Somewhat similar to modern editors, I prefer a 1-pixel wide bar
cursor. However having a distinctive shape in non-active buffers
(rather than simply not blinking as in many other programs) is also quite useful.
#+BEGIN_SRC emacs-lisp
(setq-default cursor-type '(bar . 1))
(setq-default cursor-in-non-selected-windows 'hollow)
#+END_SRC

*** Frame Titles
Window titles include a lot of unnecessary information by default. I generally
find 3 things important: the buffer name, its mode, and whether it's been saved.
#+BEGIN_SRC emacs-lisp
(setq frame-title-format '("" "%b %* [%m]"))
#+END_SRC

*** Fringe Wrap Indicators
The default fringe overage symbols are extremely ugly arrows. Unfortunately,
there is no way to use high resolution images for these. They literally must be
8x8 bitmaps, which explains why they're so ugly in the first place. However this
sequence of pseudo-dots looks a good bit better in my eyes.
#+BEGIN_SRC emacs-lisp
(define-fringe-bitmap 'right-curly-arrow
  [#b00000000
   #b00000000
   #b00000000
   #b00000000
   #b01010100
   #b01010100
   #b01010100
   #b00000000])

(define-fringe-bitmap 'left-curly-arrow
  [#b00000000
   #b00000000
   #b00000000
   #b00000000
   #b01010100
   #b01010100
   #b01010100
   #b00000000])
#+END_SRC

*** Font Lock
I want syntax highlighting everywhere, and as much as possible.
#+BEGIN_SRC emacs-lisp
(setq font-lock-maximum-decoration t)
(global-font-lock-mode t)
#+END_SRC

*** Prettify Symbols
Similarly, I like to have nice many text representations of symbols replaced
with those symbols. i.e. in =emacs-lisp= mode I see "lambda" as λ. This is
especially useful for LaTeX editing. However I also like to edit the real
underlying text easily, so I set the symbols to revert whenever the cursor is
touching.
#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode)
(setq prettify-symbols-unprettify-at-point 'right-edge)
#+END_SRC

** macOS
I run [[https://bitbucket.org/mituharu/emacs-mac/overview][Mitsuharu Yamamoto's]] =emacs-macport= on the latest
version of macOS. There are several configuration options specific to
this platform that I use.

These settings are kept in a separate file for clean tangling
conditional on the operating system.

#+BEGIN_SRC emacs-lisp
(spruce/new-config-file macOS "macOS")
(when (eq system-type 'darwin)
  (org-babel-load-file spruce/macOS-config-file))
#+END_SRC

* General
** TODO Helm
Helm is probably the most important package I use. At its core, it's just an
alternative selection system. Selection is an extremely common activity in
Emacs, selecting a file, using M-x to select a command, selecting a buffer to
switch to, etc. Helm provides a consistent, sane, and incredibly convenient
framework for selection, including the best search method I have ever seen. My
only complaint about it is going back to other applications where selecting
commands or finding files takes actual mental effort.

Helm can plug into and replace a large number of Emacs features, as well as many
other packages. I generally put such configs in the other packages, as I now
view Helm as more part of my default Emacs rather than a separate package. For
default Emacs features, a large part of this "plugging in" is just rebinding
default keybindings to Helm versions of Emacs commands.
*** Helm Proper
This is my Helm =use-package=. I use noweb to tangle source blocks below inside
the use-package.
#+BEGIN_SRC emacs-lisp :noweb tangle
(use-package helm
  :diminish helm-mode
  :init (require 'helm-config)
  :config
  ;; Enable Helm globally
  (helm-mode t)
  <<helm-fuzzy-matching>>
  <<helm-window-split>>
  <<helm-company-projectile>>
  <<helm-set-locate-command>>
  :bind (
         <<helm-replace-defaults>>
         <<helm-persistent-action>>))
#+END_SRC
Note: the below is still included inside the Helm =use-package=.
**** Fuzzy Matching
Fuzzy matching makes my typos less important and also doesn't get in my way when
I know exactly what I want.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-fuzzy-matching :tangle no
(setq helm-M-x-fuzzy-match t)
(setq helm-mode-fuzzy-match t)
#+END_SRC

**** Window Split
Default Helm can open buffers in weird and disorienting positions. I prefer it
always attempting to pop up as if from the mode line.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-window-split :tangle no
(setq helm-split-window-in-side-p t)
#+END_SRC

**** Company/Projectile
Move to company/projectile configs
#+BEGIN_SRC emacs-lisp :noweb-ref helm-company-projectile :tangle no
(with-eval-after-load 'company
  (bind-key "C-:" 'helm-company company-mode-map)
  (bind-key "C-:" 'helm-company company-active-map))
(with-eval-after-load 'projectile
  (setq projectile-completion-system 'helm))
#+END_SRC

**** Defaults Replacement
While Helm replaces several default Emacs functions to make many commands behave
better, it also has specialized versions with extra features. I replace as many
default options as possible.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-replace-defaults :tangle no
("M-x" . helm-M-x)
("C-x C-f" . helm-find-files)
("C-x b" . helm-mini)
("C-x C-b" . helm-buffers-list)
("C-c h o" . helm-occur)
("M-s o" . helm-occur)
#+END_SRC

**** Persistent Action
In Helm a persistent action is something that can be done in a Helm buffer
without ending the session. By default it's bound to C-z, and tab is bound to
selection of a non-persistent action. I prefer swapping C-z and tab
functionality.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-persistent-action :tangle no
:map helm-map
("<tab>" . helm-execute-persistent-action)
("C-i" . helm-execute-persistent-action) ; for use in terminal
("C-z" . helm-select-action)
#+END_SRC

**** Locate Command
~helm-locate~ is an extremely useful command to find arbitrary files on the
file-system. It's best to do this using an external tool. I pick which one based
on the current operating system. However if this is macOS, then this was already
set in my macOS.org config file.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-set-locate-command :tangle no
  (unless (eq system-type 'darwin)
    (setq helm-locate-command
          (case system-type
            ('gnu/linux "locate -i -r %s")
            ('berkeley-unix "locate -i %s")
            ('windows-nt "es %s")
            (t "locate %s"))))
#+END_SRC
*** Helm Flx
=flx= is a package that allows for Sublime-like great fuzzy matching. =helm-flx=
plugs in this functionality to Helm's fuzzy matching.
#+BEGIN_SRC emacs-lisp
(use-package helm-flx
  :config (helm-flx-mode t))
#+END_SRC

*** Helm Projectile
Projectile is another incredibly important package for me, and of course I'd
like to use Helm for all of its various features.
#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :config
  (with-eval-after-load 'projectile
    (helm-projectile-on)))
#+END_SRC

*** =helm-swoop=
=helm-swoop= is a replacement for ~isearch~ and ~occur~ that searches buffers with a
Helm-based interface and automatically moves through the searched buffer and
highlights the matches. It also allows for editing the searches in a separate
buffer and saving them back.
**** Swoop Proper
#+BEGIN_SRC emacs-lisp :noweb tangle
(use-package helm-swoop
  :config
  <<helm-swoop-window-splitting>>
  <<helm-swoop-output-color>>
  <<helm-swoop-reactivate-mark>>
  <<helm-swoop-ci-translation>>
  :bind (
         <<helm-swoop-search-rebinds>>
         <<helm-swoop-switch-to-multi>>))
#+END_SRC
**** Swoop Window Splitting
Do the same window split as with the rest of Helm, i.e. inside the current
buffer and vertically if possible.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-window-splitting :tangle no
(setq helm-swoop-split-with-multiple-windows t)
(setq helm-swoop-split-direction 'split-window-vertically)
#+END_SRC
**** Font Lock in Searches
Keep the font lock (color/highlighting etc) from the searched buffer in the
results. This slows down the search, but not very perceptibly.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-output-color :tangle no
(setq helm-swoop-speed-or-color t)
#+END_SRC
**** Mark Reactivation
For some reason helm-swoop deactivates the mark on search selection. This
wrapper fixes that, by wrapping helm-swoop in a function that will reactivate
the mark if it was set before search started.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-reactivate-mark :tangle no
(defun spruce/helm-swoop-mark-wrapper (original &rest search)
  "Check the state of the mark before calling helm-swoop and
re-activate it after swooping if it was active before-hand"
  (let ((marked mark-active))
    (apply original search)
    (when marked (activate-mark))))
(advice-add 'helm-swoop :around #'spruce/helm-swoop-mark-wrapper)
#+END_SRC
**** Search Keybindings
I replace the default isearch binding with swoop. I also tend to type new
searches more often than I use the symbol at the point, so I use the
no-pre-input version. However, isearch is an important tool for navigation, so I
rebind it to an easy-to-reach key, C-i. Unfortunately this is viewed by Emacs as
the same character as <tab> due to deficiencies of old keyboards. So I have to
instead have it translate a literal C-i (but not <tab>) to H-i first, and then
bind H-i to isearch.

So this block must go in :config and does the translation:
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-ci-translation :tangle no
(keyboard-translate ?\C-i ?\H-i)
#+END_SRC
and this one does the actual keybinding.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-search-rebinds :tangle no
:map global-map
("C-c s" . isearch-forward)
("H-i" . isearch-forward)
("C-s" . helm-swoop-without-pre-input)
("C-M-s" . helm-swoop) ; with input of thing-at-point
:map isearch-mode-map
("C-i" . isearch-repeat-forward)
#+END_SRC

**** Multi-Swoop
Multiswoop, swooping across multiple buffers, is pretty useful. Reasonably often
I realize a search I started in one buffer needs to expand across multiple, so I
use this binding to switch to multiswoop from inside a normal swoop.
#+BEGIN_SRC emacs-lisp :noweb-ref helm-swoop-switch-to-multi :tangle no
:map helm-swoop-map
("M-i" . helm-multi-swoop-all-from-helm-swoop)
#+END_SRC

** Projectile
#+BEGIN_SRC emacs-lisp
(projectile-global-mode)
(defun init-projectile ()
  (interactive)
  (let ((projectile ".projectile"))
    (unless (file-exists-p projectile)
      (write-region "" nil projectile))))
#+END_SRC
** Company
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-<tab>") 'company-complete)
#+END_SRC
** Appearance
*** Mode Line
The column number is often useful for me, enough to be in the mode line.
#+BEGIN_SRC emacs-lisp
(column-number-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq projectile-mode-line " Projectile")
(use-package smart-mode-line
  :config
  (setq sml/theme 'respectful)
  (setq sml/shorten-directory t)
  (setq sml/shorten-modes t)
  (setq sml/replacer-regexp-list nil)
  (setq sml/no-confirm-load-theme t)
  (setq sml/line-number-format "  %3l ")
  (sml/setup))

(use-package autorevert
  :diminish auto-revert-mode)
#+END_SRC

*** Appearance Heap
#+BEGIN_SRC emacs-lisp

(set-face-attribute 'default nil :font "Source Code Pro-12")
;; (when (and (string-match "Carbon" (emacs-version)) (window-system))
;;   (load-theme 'spacegray-spruce t))

(set-frame-font "Source Code Pro-12")
(use-package all-the-icons)
(use-package neotree)
(use-package doom-themes
  :diminish doom-buffer-mode
  :after neotree
  :config
  (setq doom-neotree-file-icons t)
  (add-hook 'find-file-hook 'doom-buffer-mode)
  ;; brighter minibuffer when active
  (add-hook 'minibuffer-setup-hook 'doom-brighten-minibuffer)
  (load-theme 'doom-one t)
  (require 'doom-neotree))
(when (boundp 'window-divider-mode)
  (setq window-divider-default-places t
        window-divider-default-bottom-width 1
        window-divider-default-right-width 1)
  (window-divider-mode +1))
#+END_SRC
** Modes
** Packages
** IRC
#+BEGIN_SRC emacs-lisp
(use-package circe)
#+END_SRC
** Misc
*** Desktop mode
#+BEGIN_SRC emacs-lisp
(setq dekstop-auto-save-timeout 300)
(if (display-graphic-p)
    (desktop-save-mode nil))
(setq desktop-dirname "~/.emacs.d/desktops/"
      desktop-path (quote ("~/.emacs.d/desktops/"))
      desktop-auto-save-timeout 30
      desktop-save nil)
#+END_SRC
* Programming
** =prog=
*** Spacing and Indentation
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (setq line-spacing nil)))
#+END_SRC

*** TODO Commenting
This function and keybinding basically do exactly what I want for commenting.
Apparently there's some shiny new options in Emacs 25 that I should probably
replace this with. Credit: [[https://lists.gnu.org/archive/html/emacs-devel/2008-12/msg00390.html][Will Farrington]].
#+BEGIN_SRC emacs-lisp
(defun comment-dwim-line (&optional arg)
  "Replacement for the comment-dwim command.
   If no region is selected and current line is not blank and we are
   not at the end of the line, then comment current line.
   Replaces default behaviour of comment-dwim, when it inserts
   comment at the end of the line."
  (interactive "*P")
  (comment-normalize-vars)
  (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
      (comment-or-uncomment-region (line-beginning-position) (line-end-position))
    (comment-dwim arg)))
(bind-key "M-;" 'comment-dwim-line prog-mode-map)
#+END_SRC

*** Heap
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq global-linum-mode nil)
(setq-default tab-width 4)
(add-hook 'prog-mode-hook (lambda () (hl-line-mode 1)))
(with-eval-after-load 'smartparens
  (smartparens-global-mode))
(add-hook 'prog-mode-hook 'global-company-mode)
(add-hook 'prog-mod (lambda () (abbrev-mode nil)))
#+END_SRC

** CC
#+BEGIN_SRC emacs-lisp
  (use-package cc-mode
    :bind (:map
           c-mode-base-map
           ("C-c b" . compile)))
(defun astyle-this-buffer (pmin pmax)
  (interactive "r")
  (shell-command-on-region pmin pmax
                           "astyle" ;; add options here...
                           (current-buffer) t
                           (get-buffer-create "*Astyle Errors*") t))
(add-hook 'c-mode-common-hook
          (lambda ()
            (require 'dtrt-indent)
            (dtrt-indent-mode nil)))
#+END_SRC

*** C++
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook (lambda () (setq c-basic-offset 4)))
#+END_SRC

*** TODO Temporary Upgrade Heap
setup rtags
#+BEGIN_SRC emacs-lisp
(use-package rtags)
#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp
(defun toggle-pdb ()
  (interactive)
  (let ((line (s-trim (thing-at-point 'line t)))
        (debug "import ipdb; ipdb.set_trace()"))
    (cond ((equal line debug)
           (kill-whole-line)
           (previous-line)
           (move-end-of-line 1))
          (t (python-nav-end-of-statement)
             (cond ((equal line "")
                    (insert debug))
                   ((not (equal (length line) 0))
                    (move-end-of-line 1)
                    (newline-and-indent)
                    (insert debug)))))))

(add-hook 'python-mode-hook
          (lambda () (local-set-key (kbd "C-c C-d") #'toggle-pdb)))

(setq python-shell-interpreter "ipython"
      python-shell-interpreter-args "-i")

(use-package jedi
  :bind (("C-c /" . jedi:show-doc)))
(eval-after-load "python-mode"
  '(define-key python-mode-map (kbd "C-c .") 'jedi:goto-definition))
(defun jedi-python-mode-hook ()
  (add-to-list 'company-backends 'company-jedi)
  (define-key python-mode-map (kbd "C-c .") 'jedi:goto-definition))

(add-hook 'python-mode-hook 'jedi-python-mode-hook)
(setq jedi:complete-on-dot t)
#+END_SRC

** Emacs Lisp
#+BEGIN_SRC emacs-lisp
(defun elisp-keybindings ()
  (local-set-key (kbd "H-e") #'eval-buffer))
(add-hook 'emacs-lisp-mode-hook 'elisp-keybindings)
#+END_SRC

** Coffeescript
#+BEGIN_SRC emacs-lisp
(setq coffee-tab-width 2)
#+END_SRC

* Org
#+BEGIN_SRC emacs-lisp
(use-package org
  :diminish org-indent-mode
  :config
  (setq org-agenda-files (list "~/Documents/Classes/school-schedule.org"
                               (concat user-emacs-directory "emacs-todo.org")))
  (setq org-bullets-bullet-list (list "●" "●" "○" "○" "○" "○" "○" "○" "○"))
  (setq org-export-backends '(ascii html icalendar latex md))
  (setq org-fontify-whole-heading-line t)
  (setq org-pretty-entities t)
  (setq org-list-allow-alphabetical t)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((R . t)
     (emacs-lisp . t)
     (python . t)
     (sh . t)))
  (setq org-startup-indented t)
  (setq org-hide-leading-stars t)
  (setq org-src-preserve-indentation nil
        org-edit-src-content-indentation 0)
  (setq org-confirm-babel-evaluate nil
        org-src-fontify-natively t
        org-src-tab-acts-natively t)
  (setq org-archive-location "~/.emacs.d/org/archive/%s-archive::")
  (setq org-startup-folded 'content)
  ;; in org mode C-a/e moves to beginning of text in line, after header asterisks
  ;; however you can press it again to go all the way
  (setq org-special-ctrl-a/e t)
  ;; don't display slashes/asterisks etc for italics/bold etc
  (setq org-hide-emphasis-markers t)
  (setq org-fontify-done-headline t
        org-fontify-quote-and-verse-blocks t)
  (set-face-attribute 'org-level-1 nil :inherit 'outline-1 :height 1.25)
  (set-face-attribute 'org-level-2 nil :inherit 'outline-2 :height 1.15)
  (add-hook 'org-mode-hook (lambda () (setq line-spacing '0.25)))
  (setq org-use-sub-superscripts "{}")
  (setq org-export-headline-levels 5)
  (setq org-src-ask-before-returning-to-edit-buffer nil)
  (setq org-src-window-setup 'current-window)
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" ""))
  (setq org-html-head-extra 
        (concat "<link rel=\"stylesheet\" type=\"text/css\" href=\""
                spruce/org-config-dirpath "/css/org-export.css\"></link>"))
  (defun spruce/org-cycle-current-subtree ()
    (interactive)
    (let ((old-tab-style org-cycle-emulate-tab))
      (setq org-cycle-emulate-tab nil)
      (org-cycle)
      (setq org-cycle-emulate-tab old-tab-style)))

  (defun spruce/org-clock-select ()
    (interactive)
    (org-clock-in '(4)))
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (with-eval-after-load 'latex
    (bind-key "H-C-j" #'LaTeX-insert-inline-math
                org-mode-map)
    (bind-key "H-C-k" #'LaTeX-insert-display-math
              org-mode-map))
  :bind (("C-c a" . org-agenda)
         ("C-c l" . org-store-link)
         ("C-c o c" . org-capture)
         ("C-c o i" . spruce/org-clock-select)
         ("C-c o o" . org-clock-out)
         ("C-c b" . org-iswitchb)
         ("C-c L" . org-insert-link-global)
         ("C-c o C-o" . org-open-at-point-global)
         ("H-M-<return>" . org-insert-subheading)
         :map org-mode-map
         ("C-<tab>" . spruce/org-cycle-current-subtree)))

(use-package org-bullets
  :config
  (add-hook 'org-mode-hook
            (lambda () (org-bullets-mode 1)))
  (setcdr org-bullets-bullet-map nil))
#+END_SRC

* LaTeX
#+BEGIN_SRC emacs-lisp
(use-package tex
  :ensure auctex
  :config
  ;; TODO: fucks up prettify for some reason?
  ;; (company-auctex-init)
  ;; save buffer style info
  (setq TeX-auto-save t)
  ;; automatically parse style info
  (setq TeX-parse-self t)
  ;; no tabs
  (setq TeX-auto-untabify t)
  ;; TODO: unsure what this does
  ;; (setq-default TeX-master 'dwim)
  (setq TeX-PDF-mode t)
  (defun spruce/TeX-open-output-buffer ()
    (interactive)
    (let ((output-file (with-current-buffer TeX-command-buffer
                         (expand-file-name
                          (TeX-active-master (TeX-output-extension))))))
      (find-file output-file)))
  (add-to-list 'TeX-view-program-list
               (list "Emacs" #'spruce/TeX-open-output-buffer))
  (setq TeX-view-program-selection '((output-pdf "Emacs")))
  ;; better name for local variable
  (setq TeX-auto-local ".auctex-auto")
  ;; auto revert pdf buffer
  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer)
  ;; show errors if there were any
  (setq TeX-error-overview-open-after-TeX-run t)
  ;; don't confirm before cleaning files
  (setq TeX-clean-confirm nil)
  (setq TeX-save-query nil)
  (defun TeX-insert-pair (arg open-str close-str)
    "Like TeX-insert-brackes but for any pair"
    (interactive "P")
    (if (TeX-active-mark)
        (progn
          (if (< (point) (mark)) (exchange-point-and-mark))
          (insert close-str)
          (save-excursion (goto-char (mark)) (insert open-str)))
      (insert open-str)
      (save-excursion
        (if arg (forward-sexp (prefix-numeric-value arg)))
        (insert close-str))))

  (setq TeX-electric-sub-and-superscript t)

  (use-package latex
    :ensure nil
    :config
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (setq LaTeX-math-menu-unicode t)
    (add-hook 'LaTeX-mode-hook (lambda () (latex-electric-env-pair-mode t)))
    (add-hook 'LaTeX-mode-hook
              (lambda () (set-fill-column 90)))
    (add-hook 'LaTeX-mode-hook 'turn-on-auto-fill)
    (add-hook 'LaTeX-mode-hook (lambda () (prettify-symbols-mode)))
    (defun LaTeX-insert-inline-math (arg)
      (interactive "P")
      (TeX-insert-pair arg "\\( " " \\)"))
    (defun LaTeX-insert-display-math (arg)
      (interactive "P")
      (TeX-insert-pair arg "\\[ " " \\]"))
    (defun spruce/LaTeX-mode-keybindings ()
      (bind-key "H-C-j" #'LaTeX-insert-inline-math
                (current-local-map))
      (bind-key "H-C-k" #'LaTeX-insert-display-math
                (current-local-map)))
    (add-hook 'LaTeX-mode-hook #'spruce/LaTeX-mode-keybindings)
    (with-eval-after-load 'smartparens
      (add-hook 'TeX-mode-hook #'smartparens-mode))
    (use-package font-latex
      :ensure nil
      :config
      (set-face-attribute 'font-latex-sedate-face nil
                          :inherit 'font-lock-constant-face
                          :foreground 'unspecified)))

  (put 'TeX-command-extra-options 'safe-local-variable
       (lambda (x) (string-equal x "-shell-escape"))))

(use-package reftex
  :diminish reftex-mode
  :config
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
  (setq reftex-plug-into-AUCTeX t))

(setq latex-templates-directory "~/.emacs.d/templates/latex-templates/")
(defun latex-template ()
  (interactive)
  (let* ((files (file-expand-wildcards (concat latex-templates-directory "*.tex")))
         (selection (completing-read "LaTeX Template: "
                                     (mapcar #'file-name-base files))))
    (insert-file-contents (concat latex-templates-directory selection ".tex"))))
#+END_SRC

* The Heap
Sometimes I want to test out a tweak or fix an annoyance fast, without putting
in the time to document how or why. This is a bad habit, but sometimes
necessary. The Heap is where all of that temporarily unfiled code goes.
** Package Heap
*** Tramp
#+BEGIN_SRC emacs-lisp
(use-package tramp
  :config
  (setq tramp-ssh-controlmaster-options
        "-o ControlMaster=auto -o ControlPath='tramp.%%C' -o ControlPersist=yes")
  (setq tramp-default-method "ssh"))
#+END_SRC
*** recentf
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :config
  (setq recentf-max-menu-items 100)
  (recentf-mode t)
  :bind ("C-x C-r" . helm-recentf))
#+END_SRC
*** undo-tree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (setq undo-tree-auto-save-history t)
  (add-to-list 'undo-tree-history-directory-alist
               '("." . "~/.emacs.d/cache/undo"))
  (global-undo-tree-mode))
#+END_SRC
*** flyspell
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :diminish
  :config
  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
  (defun spruce/enable-text-flyspell ()
    (flyspell-mode t))
  (add-hook 'text-mode-hook #'spruce/enable-text-flyspell))
#+END_SRC
*** xscheme
#+BEGIN_SRC emacs-lisp
(use-package xscheme)
#+END_SRC
*** magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
  (setq magit-last-seen-setup-instructions "1.4.0")
  (setq magit-auto-revert-mode t)
  :bind ("C-c g" . magit-status))
#+END_SRC
*** markdown-mode
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode "\\.md\\'"
  :config
  (add-hook 'markdown-mode-hook 'visual-line-mode))
#+END_SRC
*** smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :diminish smartparens-mode
  :config
  (require 'smartparens-config)
  (global-set-key (kbd "C-M-<backspace>") 'sp-unwrap-sexp)
  (setq sp-navigate-consider-stringlike-sexp
        (append sp-navigate-consider-stringlike-sexp (list 'python-mode
                                                           'org-mode
                                                           'coffeescript-mode)))
  (setq sp-highlight-pair-overlay nil))
#+END_SRC
*** persistent-scratch
#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :config (persistent-scratch-setup-default))
#+END_SRC
*** transpose-frame
#+BEGIN_SRC emacs-lisp
(use-package transpose-frame)
#+END_SRC
*** buffer-move
#+BEGIN_SRC emacs-lisp
(use-package buffer-move)
#+END_SRC
*** fill-column-indicator
#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator)
#+END_SRC
*** ESS
#+BEGIN_SRC emacs-lisp
(use-package ess
  :init (require 'ess-site))
#+END_SRC 
** Old Heap
#+BEGIN_SRC emacs-lisp
(when (string-equal system-name "Spruces-MacBook-Pro.local")
  (add-to-list 'load-path "/usr/local/Cellar/zlib/1.2.8/lib/pkgconfig")
  (add-to-list 'load-path "/usr/local/lib/pkgconfig")
  (add-to-list 'load-path "/opt/X11/lib/pkgconfig"))

(setq exec-path (append exec-path '(":/usr/local/bin")))
(setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
(setq exec-path (append exec-path '(":/usr/texbin")))
(setenv "PATH" (concat (getenv "PATH") ":/usr/texbin"))

(setq doc-view-continuous t)
(setq doc-view-ghostscript-program "/usr/local/bin/gs")

;; Use Source Code Sans (pretty variable width font) for org mode
;;; function that sets current buffer to Source Code Sans
;; (defun my-buffer-face-mode-variable ()
;;   "Set font to a variable width (proportional) fonts in current buffer"
;;   (interactive)
;;   (setq buffer-face-mode-face '(:family "Source Code Sans" :height 100 :width semi-condensed))
;;   (buffer-face-mode))



(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
(add-hook 'coffeescript-mode-hook 'whitespace-mode)
(add-hook 'python-mode-hook 'whitespace-mode)
(setq whitespace-style
      '(face trailing space-before-tab tab
             indentation empty space-after-tab))
;; don't do anything whitespace, use whitespace-fn instead
(setq whitespace-action nil)

(defun whitespace-save-fn ()
  (add-hook 'before-save-hook
            'delete-trailing-whitespace-except-current-line
            nil 'local))

(add-hook 'c-mode-common-hook #'whitespace-save-fn)
(add-hook 'python-mode-hook #'whitespace-save-fn)
(add-hook 'lisp-mode-hook #'whitespace-save-fn)
(add-hook 'prog-mode-hook #'whitespace-mode)
(add-hook 'prog-mode-hook (lambda () (hl-line-mode 1)))
;; (setq auto-revert-use-notify nil)

(setq whitespace-line-column 86)
(setq hl-line-sticky-flag nil)
#+END_SRC
* Utility Functions
These functions are bound to keys and used in various places in my config.
Functions are only here if I felt they were sufficiently general, not tied to a
specific setting. Documentation is generally provided in the docstring rather
than through =org=. This code block is not tangled, rather it is included through
=noweb= near the top of this file.

#+BEGIN_SRC emacs-lisp :noweb-ref utility-functions :tangle no
;; see http://ergoemacs.org/emacs/modernization_elisp_lib_problem.html
(defun s-trim-left (s)
  "Remove whitespace at the beginning of S."
  (if (string-match "\\`[ \t\n\r]+" s)
      (replace-match "" t t s)
    s))

(defun s-trim-right (s)
  "Remove whitespace at the end of S."
  (if (string-match "[ \t\n\r]+\\'" s)
      (replace-match "" t t s)
    s))

(defun s-trim (s)
  "Remove whitespace at the beginning and end of S."
  (s-trim-left (s-trim-right s)))

(defun delete-trailing-whitespace-except-current-line ()
  (interactive)
  (let ((begin (line-beginning-position))
        (end (line-end-position)))
    (save-excursion
      (when (< (point-min) begin)
        (save-restriction
          (narrow-to-region (point-min) (1- begin))
          (delete-trailing-whitespace)))
      (when (> (point-max) end)
        (save-restriction
          (narrow-to-region (1+ end) (point-max))
          (delete-trailing-whitespace))))))

;; from http://stackoverflow.com/questions/15580913/
(defun toggle-quotes ()
  (interactive)
  (save-excursion
    (let ((start (nth 8 (syntax-ppss)))
          (quote-length 0) sub kind replacement)
      (goto-char start)
      (setq sub (buffer-substring start (progn (forward-sexp) (point)))
            kind (aref sub 0))
      (while (char-equal kind (aref sub 0))
        (setq sub (substring sub 1)
              quote-length (1+ quote-length)))
      (setq sub (substring sub 0 (- (length sub) quote-length)))
      (goto-char start)
      (delete-region start (+ start (* 2 quote-length) (length sub)))
      (setq kind (if (char-equal kind ?\") ?\' ?\"))
      (loop for i from 0
            for c across sub
            for slash = (char-equal c ?\\)
            then (if (and (not slash) (char-equal c ?\\)) t nil) do
            (unless slash
              (when (member c '(?\" ?\'))
                (aset sub i
                      (if (char-equal kind ?\") ?\' ?\")))))
      (setq replacement (make-string quote-length kind))
      (insert replacement sub replacement))))

(defun move-line-up ()
  "Move up the current line."
  (interactive)
  (transpose-lines 1)
  (forward-line -2)
  (indent-according-to-mode))

(defun move-line-down ()
  "Move down the current line."
  (interactive)
  (forward-line 1)
  (transpose-lines 1)
  (forward-line -1)
  (indent-according-to-mode))

(defun revert-buffer-no-prompt ()
  "Revert buffer without confirm prompt"
  (interactive)
  (revert-buffer t t))

(defun backward-kill-line (arg)5
  "Kill ARG lines backward."
  (interactive "p")
  (kill-line (- 1 arg)))
#+END_SRC
